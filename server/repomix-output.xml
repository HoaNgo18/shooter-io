This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.env.example
package.json
src/api/auth.js
src/config.js
src/core/Game.js
src/core/Physics.js
src/core/Server.js
src/db/models/User.model.js
src/db/mongo.js
src/entities/Entity.js
src/entities/Player.js
src/entities/Projectile.js
src/index.js
src/utils/Quadtree.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="package.json">
{
  "name": "io-game-server",
  "version": "1.0.0",
  "type": "module",
  "main": "src/index.js",
  "scripts": {
    "dev": "nodemon src/index.js",
    "start": "node src/index.js"
  },
  "dependencies": {
    "ws": "^8.16.0",
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "mongoose": "^8.0.3",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.2",
    "io-game-shared": "*"
  },
  "devDependencies": {
    "nodemon": "^3.0.2"
  }
}
</file>

<file path="src/api/auth.js">
import express from 'express';
import jwt from 'jsonwebtoken';
// L∆∞u √Ω: ƒê∆∞·ªùng d·∫´n n√†y ƒë√£ ƒë∆∞·ª£c s·ª≠a ƒë·ªÉ ƒë√∫ng v·ªõi c·∫•u tr√∫c models
import { User } from '../db/models/User.model.js';
import config from '../config.js';

const router = express.Router();

// Register
router.post('/register', async (req, res) => {
  try {
    const { username, email, password } = req.body;

    // Validation
    if (!username || !email || !password) {
      return res.status(400).json({ error: 'All fields required' });
    }

    // Check if user exists
    const existingUser = await User.findOne({ 
      $or: [{ username }, { email }] 
    });
    
    if (existingUser) {
      return res.status(400).json({ error: 'User already exists' });
    }

    // Create user
    const user = new User({ username, email, password });
    await user.save();

    // Generate token
    const token = jwt.sign({ id: user._id }, config.JWT_SECRET, {
      expiresIn: '7d'
    });

    res.status(201).json({
      token,
      user: {
        id: user._id,
        username: user.username,
        email: user.email,
        highScore: user.highScore
      }
    });
  } catch (error) {
    console.error('Register error:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

// Login
router.post('/login', async (req, res) => {
  try {
    const { username, password } = req.body;

    // Find user
    const user = await User.findOne({ username });
    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Check password
    const isMatch = await user.comparePassword(password);
    if (!isMatch) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Generate token
    const token = jwt.sign({ id: user._id }, config.JWT_SECRET, {
      expiresIn: '7d'
    });

    res.json({
      token,
      user: {
        id: user._id,
        username: user.username,
        email: user.email,
        highScore: user.highScore,
        coins: user.coins
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

// Get profile (protected route)
router.get('/profile', async (req, res) => {
  try {
    const token = req.headers.authorization?.split(' ')[1];
    if (!token) {
      return res.status(401).json({ error: 'No token provided' });
    }

    const decoded = jwt.verify(token, config.JWT_SECRET);
    const user = await User.findById(decoded.id).select('-password');
    
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    res.json({ user });
  } catch (error) {
    res.status(401).json({ error: 'Invalid token' });
  }
});

export default router;
</file>

<file path="src/config.js">
import dotenv from 'dotenv';
dotenv.config();

export default {
  WS_PORT: process.env.WS_PORT || 3000,
  HTTP_PORT: process.env.HTTP_PORT || 8080,
  MONGODB_URI: process.env.MONGODB_URI || 'mongodb://localhost:27017/io-game',
  JWT_SECRET: process.env.JWT_SECRET || 'change-this-secret-key',
  NODE_ENV: process.env.NODE_ENV || 'development'
};
</file>

<file path="src/core/Game.js">
import { TICK_RATE, MAP_SIZE, FOOD_COUNT } from '../../../shared/src/constants.js'; // Gom import l·∫°i cho g·ªçn
import { PacketType } from '../../../shared/src/packetTypes.js';
import { Player } from '../entities/Player.js';
import { Physics } from './Physics.js';

export class Game {
  constructor(server) {
    this.server = server;
    this.players = new Map();
    this.projectiles = [];
    this.physics = new Physics(this);
    this.tickInterval = null;
    this.lastTick = Date.now();
    
    // Qu·∫£n l√Ω th·ª©c ƒÉn
    this.foods = []; 
    this.initFood();
  }

  start() {
    const tickDelay = 1000 / TICK_RATE;
    this.tickInterval = setInterval(() => this.tick(), tickDelay);
    console.log(`Game loop started at ${TICK_RATE} ticks/sec`);
  }

  initFood() {
    for (let i = 0; i < FOOD_COUNT; i++) {
      this.foods.push(this.generateRandomFood());
    }
  }

  generateRandomFood() {
    // Random v·ªã tr√≠ trong map
    const max = MAP_SIZE / 2;
    return {
      id: Math.random().toString(36).substr(2, 9),
      x: (Math.random() * MAP_SIZE) - max,
      y: (Math.random() * MAP_SIZE) - max,
      type: Math.floor(Math.random() * 3) // 0: ƒê·ªè, 1: Xanh, 2: Lam
    };
  }

  tick() {
    const now = Date.now();
    let dt = (now - this.lastTick) / 1000;
    this.lastTick = now;

    // üü¢ S·ª¨A L·ªñI LAG: Gi·ªõi h·∫°n dt t·ªëi ƒëa (ch·ªëng nh·∫£y c√≥c khi lag)
    if (dt > 0.05) {
        dt = 0.05;
    }

    // üî¥ B·ªé ƒêO·∫†N CODE UPDATE C≈® ·ªû ƒê√ÇY ƒêI (ƒë·ªÉ tr√°nh update 2 l·∫ßn)

    // Update projectiles
    for (let i = this.projectiles.length - 1; i >= 0; i--) {
      const proj = this.projectiles[i];
      proj.update(dt);
      
      if (proj.shouldRemove()) {
        this.projectiles.splice(i, 1);
      }
    }

    // Update players (Ch·ªâ ng∆∞·ªùi s·ªëng)
    this.players.forEach(player => {
        if (!player.dead) { 
            player.update(dt);
        }
    });

    // Check collisions
    this.physics.checkCollisions();

    // üü¢ S·ª¨A LOGIC FOOD: Ch·ªâ th√™m m·ªõi n·∫øu thi·∫øu (Logic c≈© c·ªßa b·∫°n ƒë√∫ng r·ªìi)
    if (this.foods.length < FOOD_COUNT) {
       this.foods.push(this.generateRandomFood());
    }

    // Send state updates to all clients
    this.sendStateUpdate();
  }

  addPlayer(clientId, name) {
    const player = new Player(clientId, name);
    this.players.set(clientId, player);

    // Send init packet to new player
    this.server.sendToClient(clientId, {
      type: PacketType.INIT,
      id: clientId,
      player: player.serialize(),
      players: Array.from(this.players.values()).map(p => p.serialize()),
      foods: this.foods // üü¢ G·ª≠i lu√¥n food hi·ªán c√≥ cho ng∆∞·ªùi m·ªõi v√†o
    });

    this.server.broadcast({
      type: PacketType.PLAYER_JOIN,
      player: player.serialize()
    }, clientId);

    console.log(`Player joined: ${name} (${clientId})`);
  }

  removePlayer(clientId) {
    const player = this.players.get(clientId);
    if (player) {
      this.players.delete(clientId);
      console.log(`Player removed: ${player.name}`);
    }
  }

  handleInput(clientId, inputData) {
    const player = this.players.get(clientId);
    // üü¢ TH√äM CHECK: Ch·ªâ x·ª≠ l√Ω input n·∫øu c√≤n s·ªëng
    if (player && !player.dead) {
      player.setInput(inputData);
    }
  }

  handleAttack(clientId) {
    const player = this.players.get(clientId);
    // üü¢ TH√äM CHECK: Ch·ªâ b·∫Øn ƒë∆∞·ª£c n·∫øu c√≤n s·ªëng
    if (player && !player.dead) {
      const projectile = player.attack();
      if (projectile) {
        this.projectiles.push(projectile);
      }
    }
  }

  respawnPlayer(clientId) {
    const player = this.players.get(clientId);
    if (player && player.dead) {
        player.dead = false;
        player.respawn(); 
        // Logic b√°o h·ªìi sinh s·∫Ω n·∫±m trong g√≥i tin UPDATE ti·∫øp theo (dead = false)
    }
  }

  sendStateUpdate() {
    const state = {
      type: PacketType.UPDATE,
      t: Date.now(),
      players: Array.from(this.players.values()).map(p => p.serialize()),
      projectiles: this.projectiles.map(p => p.serialize()),
      foods: this.foods // üü¢ QUAN TR·ªåNG: Ph·∫£i g·ª≠i m·∫£ng food v·ªÅ client m·ªõi v·∫Ω ƒë∆∞·ª£c
    };

    this.server.broadcast(state);
  }

  getLeaderboard() {
    return Array.from(this.players.values())
      .sort((a, b) => b.score - a.score)
      .slice(0, 10)
      .map(p => ({ name: p.name, score: p.score }));
  }
}
</file>

<file path="src/core/Physics.js">
import { circleCollision } from '../../../shared/src/utils.js';
// üü¢ GOM T·∫§T C·∫¢ IMPORT V√ÄO 1 D√íNG DUY NH·∫§T
import { PLAYER_RADIUS, MAP_SIZE, FOOD_RADIUS, XP_PER_FOOD } from '../../../shared/src/constants.js';
import { Quadtree } from '../utils/Quadtree.js';

export class Physics {
  constructor(game) {
    this.game = game;
  }

  checkCollisions() {
    // 1. Kh·ªüi t·∫°o Quadtree cho frame hi·ªán t·∫°i
    // Boundary bao tr√πm c·∫£ b·∫£n ƒë·ªì
    const boundary = { x: 0, y: 0, width: MAP_SIZE, height: MAP_SIZE };
    const qt = new Quadtree(boundary, 4); // Capacity = 4

    // 2. N·∫°p t·∫•t c·∫£ Players v√†o Quadtree
    this.game.players.forEach(player => {
      qt.insert({
        x: player.x,
        y: player.y,
        userData: player // L∆∞u tham chi·∫øu player
      });
    });

    // 3. Ki·ªÉm tra va ch·∫°m: ƒê·∫°n vs Players (D√πng Quadtree)
    this.game.projectiles.forEach(proj => {
      if (proj.hit) return;

      // T·∫°o v√πng t√¨m ki·∫øm quanh vi√™n ƒë·∫°n (h√¨nh ch·ªØ nh·∫≠t nh·ªè)
      const range = {
        x: proj.x,
        y: proj.y,
        width: PLAYER_RADIUS * 2,
        height: PLAYER_RADIUS * 2
      };

      // H·ªèi Quadtree: "C√≥ ai ·ªü g·∫ßn vi√™n ƒë·∫°n n√†y kh√¥ng?"
      const candidates = qt.query(range);

      // Ch·ªâ check va ch·∫°m k·ªπ v·ªõi nh·ªØng ng∆∞·ªùi ·ªü g·∫ßn
      for (let point of candidates) {
        const player = point.userData;

        // B·ªè qua ch·ªß nh√¢n vi√™n ƒë·∫°n
        if (player.id === proj.ownerId) continue;

        // Check va ch·∫°m h√¨nh tr√≤n ch√≠nh x√°c
        if (circleCollision(player.x, player.y, PLAYER_RADIUS, proj.x, proj.y, 5)) {
          player.takeDamage(proj.damage, proj.ownerId);
          proj.hit = true;

          if (player.isDead()) {
            this.handlePlayerDeath(player, proj.ownerId);
          }
          break; // M·ªôt vi√™n ƒë·∫°n ch·ªâ tr√∫ng 1 ng∆∞·ªùi r·ªìi m·∫•t
        }
      }
    });

    // 4. Player vs Player (Gi·ªØ nguy√™n logic ƒë·∫©y nhau ho·∫∑c c≈©ng d√πng Quadtree t∆∞∆°ng t·ª±)
    // T·∫°m th·ªùi gi·ªØ nguy√™n logic c≈© cho Player vs Player v√¨ s·ªë l∆∞·ª£ng player √≠t h∆°n ƒë·∫°n
    const players = Array.from(this.game.players.values());
    for (let i = 0; i < players.length; i++) {
      for (let j = i + 1; j < players.length; j++) {
        this.resolvePlayerCollision(players[i], players[j]);
      }
    }
    // üü¢ TH√äM: Player vs Food collision (ƒÇn)
    // Duy·ªát qua t·∫•t c·∫£ player c√≤n s·ªëng
    this.game.players.forEach(player => {
      if (player.dead) return;

      // Logic ƒë∆°n gi·∫£n: Check kho·∫£ng c√°ch v·ªõi T·∫§T C·∫¢ food
      // (Sau n√†y t·ªëi ∆∞u b·∫±ng Quadtree sau n·∫øu lag)
      for (let i = this.game.foods.length - 1; i >= 0; i--) {
        const food = this.game.foods[i];

        // T√≠nh kho·∫£ng c√°ch
        const dx = player.x - food.x;
        const dy = player.y - food.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        // N·∫øu ch·∫°m v√†o (L∆∞u √Ω: player.radius s·∫Ω tƒÉng khi l√™n c·∫•p)
        if (dist < (player.radius || PLAYER_RADIUS) + FOOD_RADIUS) {
          // 1. C·ªông ƒëi·ªÉm
          player.score += XP_PER_FOOD;
          player.checkLevelUp(); // H√†m n√†y s·∫Ω vi·∫øt ·ªü b∆∞·ªõc sau

          // 2. X√≥a food kh·ªèi m·∫£ng
          this.game.foods.splice(i, 1);
        }
      }
    });

  }
  resolvePlayerCollision(p1, p2) {
    const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
    const minDist = PLAYER_RADIUS * 2;

    if (dist < minDist) {
      const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
      const overlap = (minDist - dist) / 2;

      p1.x -= Math.cos(angle) * overlap;
      p1.y -= Math.sin(angle) * overlap;
      p2.x += Math.cos(angle) * overlap;
      p2.y += Math.sin(angle) * overlap;
    }
  }

  handlePlayerDeath(player, killerId) {
    const killer = this.game.players.get(killerId);
    if (killer) {
      killer.score += 100;
      killer.health = Math.min(killer.health + 20, killer.maxHealth); // Th∆∞·ªüng m√°u cho k·∫ª gi·∫øt
    }

    // üü¢ THAY ƒê·ªîI LOGIC: ƒê√°nh d·∫•u ch·∫øt ch·ª© kh√¥ng h·ªìi sinh ngay
    player.dead = true;
    player.health = 0;

    // ƒê·∫©y player ra ch·ªó kh√°c ho·∫∑c ·∫©n ƒëi (t√πy ch·ªçn, ·ªü ƒë√¢y ta gi·ªØ nguy√™n v·ªã tr√≠ x√°c ch·∫øt)

    this.game.server.broadcast({
      type: 'player_died', // Ho·∫∑c PacketType.PLAYER_DIED
      victimId: player.id,
      killerId: killerId
    });
  }
  clampToMap(entity) {
    const max = MAP_SIZE / 2 - PLAYER_RADIUS;
    entity.x = Math.max(-max, Math.min(max, entity.x));
    entity.y = Math.max(-max, Math.min(max, entity.y));
  }
}
</file>

<file path="src/core/Server.js">
import { WebSocketServer } from 'ws';
import { PacketType } from '../../../shared/src/packetTypes.js';
import { Game } from './Game.js';

export class Server {
  constructor(port = 3000) {
    this.wss = new WebSocketServer({ port });
    this.game = new Game(this);
    this.clients = new Map();
    
    console.log(`WebSocket server running on port ${port}`);
    this.setupWSS();
  }

  setupWSS() {
    this.wss.on('connection', (ws) => {
      const clientId = this.generateId();
      console.log(`Client connected: ${clientId}`);
      
      this.clients.set(clientId, { ws, id: clientId, player: null });

      ws.on('message', (data) => {
        try {
          const packet = JSON.parse(data.toString());
          this.handleMessage(clientId, packet);
        } catch (err) {
          console.error('Invalid packet:', err);
        }
      });

      ws.on('close', () => {
        console.log(`Client disconnected: ${clientId}`);
        this.game.removePlayer(clientId);
        this.clients.delete(clientId);
        this.broadcast({ type: PacketType.PLAYER_LEAVE, id: clientId });
      });

      ws.on('error', (err) => console.error('WebSocket error:', err));
    });
  }

  handleMessage(clientId, packet) {
    switch (packet.type) {
      case PacketType.JOIN:
        this.game.addPlayer(clientId, packet.name || 'Anonymous');
        break;
      case PacketType.INPUT:
        this.game.handleInput(clientId, packet.data);
        break;
      case PacketType.ATTACK:
        this.game.handleAttack(clientId);
        break;
      case PacketType.PONG:
        const client = this.clients.get(clientId);
        if (client?.player) {
          client.player.lastPong = Date.now();
        }
        break;
      case PacketType.RESPAWN: // üü¢ TH√äM CASE N√ÄY
        this.game.respawnPlayer(clientId);
        break;
    }
  }

  sendToClient(clientId, data) {
    const client = this.clients.get(clientId);
    if (client?.ws.readyState === 1) {
      client.ws.send(JSON.stringify(data));
    }
  }

  broadcast(data, excludeId = null) {
    const message = JSON.stringify(data);
    this.clients.forEach((client, id) => {
      if (id !== excludeId && client.ws.readyState === 1) {
        client.ws.send(message);
      }
    });
  }

  generateId() {
    return Math.random().toString(36).substr(2, 9);
  }

  start() {
    this.game.start();
  }
}
</file>

<file path="src/db/models/User.model.js">
import mongoose from 'mongoose';
import bcrypt from 'bcryptjs';

const userSchema = new mongoose.Schema({
  username: {
    type: String,
    required: true,
    unique: true,
    trim: true,
    minlength: 3,
    maxlength: 20
  },
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true
  },
  password: {
    type: String,
    required: true,
    minlength: 6
  },
  highScore: {
    type: Number,
    default: 0
  },
  totalKills: {
    type: Number,
    default: 0
  },
  totalDeaths: {
    type: Number,
    default: 0
  },
  coins: {
    type: Number,
    default: 0
  },
  skins: {
    type: [String],
    default: ['default']
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

// Hash password before saving
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  
  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error);
  }
});

// Method to compare password
userSchema.methods.comparePassword = async function(candidatePassword) {
  return await bcrypt.compare(candidatePassword, this.password);
};

export const User = mongoose.model('User', userSchema);
</file>

<file path="src/db/mongo.js">
import mongoose from 'mongoose';
import config from '../config.js';

export async function connectDB() {
  try {
    await mongoose.connect(config.MONGODB_URI);
    console.log('MongoDB connected successfully');
  } catch (error) {
    console.error('MongoDB connection error:', error);
    throw error;
  }
}

export default mongoose;
</file>

<file path="src/entities/Entity.js">
export class Entity {
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
    this.vx = 0;
    this.vy = 0;
  }

  update(dt) {
    this.x += this.vx * dt;
    this.y += this.vy * dt;
  }

  serialize() {
    return {
      x: Math.round(this.x),
      y: Math.round(this.y)
    };
  }
}
</file>

<file path="src/entities/Player.js">
import { Entity } from './Entity.js';
import {
  PLAYER_SPEED,
  PLAYER_MAX_HEALTH,
  WEAPON_TYPES,
  MAP_SIZE,
  PLAYER_RADIUS,
  REGEN_DELAY,
  REGEN_RATE,
  DASH_DURATION, DASH_COOLDOWN, DASH_MULTIPLIER
} from '../../../shared/src/constants.js';
import { getRandomPosition } from '../../../shared/src/utils.js';
import { Projectile } from './Projectile.js';


export class Player extends Entity {
  constructor(id, name) {
    const pos = getRandomPosition(MAP_SIZE);
    super(pos.x, pos.y);

    this.id = id;
    this.name = name;
    this.health = PLAYER_MAX_HEALTH;
    this.maxHealth = PLAYER_MAX_HEALTH;
    this.score = 0;
    this.weapon = 'BOW';
    this.angle = 0;
    this.dead = false;
    this.lastDamageTime = 0;
    this.lastAttack = 0;
    this.radius = PLAYER_RADIUS;
    // üü¢ TH√äM: Bi·∫øn qu·∫£n l√Ω Dash
    this.dashEndTime = 0;       // Th·ªùi ƒëi·ªÉm k·∫øt th√∫c l∆∞·ªõt
    this.dashCooldownTime = 0;  // Th·ªùi ƒëi·ªÉm h·ªìi chi√™u xong

    this.input = {
      up: false, down: false, left: false, right: false,
      mouseX: 0, mouseY: 0,
      space: false // üü¢ TH√äM: N√∫t Space
    };
  }

  setInput(data) {
    // 1. C·∫≠p nh·∫≠t c√°c ph√≠m di chuy·ªÉn (merge v√†o input hi·ªán t·∫°i ƒë·ªÉ kh√¥ng m·∫•t mouseX c≈©)
    if (data.movement) {
        Object.assign(this.input, data.movement);
    }

    // 2. üü¢ S·ª¨A L·ªñI: L∆∞u t·ªça ƒë·ªô v√†o 'this.input' ch·ª© kh√¥ng ph·∫£i 'this'
    if (data.mouseX !== undefined) {
        this.input.mouseX = data.mouseX; 
    }
    
    if (data.mouseY !== undefined) {
        this.input.mouseY = data.mouseY;
    }
  }

  update(dt) {
    if (this.dead) return;

    // üü¢ 1. X·ª≠ l√Ω Input Dash
    // N·∫øu b·∫•m Space V√Ä ƒê√£ h·ªìi chi√™u xong
    if (this.input.space && Date.now() > this.dashCooldownTime) {
      // B·∫Øt ƒë·∫ßu Dash
      this.dashEndTime = Date.now() + DASH_DURATION;
      this.dashCooldownTime = Date.now() + DASH_COOLDOWN;
    }

    // üü¢ 2. T√≠nh to√°n t·ªëc ƒë·ªô
    let currentSpeed = PLAYER_SPEED; // T·ªëc ƒë·ªô g·ªëc

    // T√≠nh gi·∫£m t·ªëc do k√≠ch th∆∞·ªõc (Code c≈© c·ªßa b·∫°n)
    const sizeFactor = this.radius / PLAYER_RADIUS;
    currentSpeed = currentSpeed / Math.sqrt(sizeFactor);

    // Ki·ªÉm tra xem c√≥ ƒëang trong th·ªùi gian Dash kh√¥ng?
    if (Date.now() < this.dashEndTime) {
      currentSpeed *= DASH_MULTIPLIER; // TƒÉng t·ªëc g·∫•p 3
    }

    // üü¢ 3. Di chuy·ªÉn (Code c≈© nh∆∞ng thay h·∫±ng s·ªë b·∫±ng bi·∫øn currentSpeed)
    let dx = 0;
    let dy = 0;
    if (this.input.up) dy -= 1;
    if (this.input.down) dy += 1;
    if (this.input.left) dx -= 1;
    if (this.input.right) dx += 1;

    if (dx !== 0 || dy !== 0) {
      const length = Math.sqrt(dx * dx + dy * dy);
      dx /= length;
      dy /= length;

      // L∆∞u √Ω: ƒê·∫£m b·∫£o c√¥ng th·ª©c n√†y kh·ªõp v·ªõi logic file Game.js c·ªßa b·∫°n
      this.x += dx * currentSpeed * dt;
      this.y += dy * currentSpeed * dt;
    }

    this.angle = Math.atan2(this.input.mouseY - this.y, this.input.mouseX - this.x);

    this.regenerate(dt); // H·ªìi m√°u
    this.clampToMap();   // Kh√¥ng ch·∫°y ra kh·ªèi map
  }

  // üü¢ TH√äM: H√†m check level up
  checkLevelUp() {
    // C√¥ng th·ª©c ƒë∆°n gi·∫£n: C·ª© 100 ƒëi·ªÉm tƒÉng 10% k√≠ch th∆∞·ªõc
    // Scale = 1 + (Score / 1000)
    const scaleFactor = 1 + (this.score / 500);

    // C·∫≠p nh·∫≠t b√°n k√≠nh va ch·∫°m
    this.radius = PLAYER_RADIUS * scaleFactor;

    // Gi·ªõi h·∫°n max size (v√≠ d·ª• to g·∫•p 3 th√¥i)
    if (this.radius > PLAYER_RADIUS * 3) {
      this.radius = PLAYER_RADIUS * 3;
    }
  }

  attack() {
    const now = Date.now();
    const weaponData = WEAPON_TYPES[this.weapon];

    if (now - this.lastAttack < weaponData.cooldown) {
      return null;
    }

    this.lastAttack = now;

    if (this.weapon === 'BOW') {
      return new Projectile(
        this.x,
        this.y,
        this.angle,
        weaponData.projectileSpeed,
        weaponData.damage,
        this.id
      );
    }

    // Melee weapons handled differently (no projectile)
    return null;
  }

  takeDamage(amount, attackerId) {
    this.health -= amount;

    // üü¢ TH√äM: Ghi l·∫°i th·ªùi ƒëi·ªÉm b·ªã ƒë√°nh
    this.lastDamageTime = Date.now();

    if (this.health < 0) this.health = 0;
  }

  isDead() {
    return this.health <= 0;
  }

  respawn() {
    const pos = getRandomPosition(MAP_SIZE);
    this.x = pos.x;
    this.y = pos.y;
    this.health = this.maxHealth;
    this.score = Math.max(0, this.score - 50);
  }

  clampToMap() {
    const max = MAP_SIZE / 2 - 20;
    this.x = Math.max(-max, Math.min(max, this.x));
    this.y = Math.max(-max, Math.min(max, this.y));
  }
  // üü¢ H√ÄM M·ªöI: Logic t·ª± h·ªìi m√°u
  regenerate(dt) {
    // 1. Ki·ªÉm tra xem ƒë√£ ƒë·∫ßy m√°u ch∆∞a? ƒê·∫ßy r·ªìi th√¨ th√¥i
    if (this.health >= this.maxHealth) {
      this.health = this.maxHealth;
      return;
    }

    // 2. Ki·ªÉm tra th·ªùi gian ch·ªù (Out of combat)
    // N·∫øu th·ªùi gian hi·ªán t·∫°i - l·∫ßn cu·ªëi b·ªã ƒë√°nh > 3 gi√¢y
    if (Date.now() - this.lastDamageTime > REGEN_DELAY) {

      // 3. C·ªông m√°u
      // C√¥ng th·ª©c: T·ªëc ƒë·ªô * th·ªùi gian tr√¥i qua (ƒë·ªÉ m∆∞·ª£t ·ªü m·ªçi FPS)
      this.health += REGEN_RATE * dt;

      // 4. Kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° Max Health
      if (this.health > this.maxHealth) {
        this.health = this.maxHealth;
      }
    }
  }

  serialize() {
    return {
      id: this.id,
      name: this.name,
      x: Math.round(this.x),
      y: Math.round(this.y),
      angle: this.angle,
      health: this.health,
      maxHealth: this.maxHealth,
      score: this.score,
      dead: this.dead,
      weapon: this.weapon,
      radius: this.radius,
      dashCooldown: this.dashCooldownTime // G·ª≠i th·ªùi gian h·ªìi xong
    };
  }
}
</file>

<file path="src/entities/Projectile.js">
import { Entity } from './Entity.js';
import { ENTITY_TYPES, MAP_SIZE } from '../../../shared/src/constants.js';

export class Projectile extends Entity {
  constructor(x, y, angle, speed, damage, ownerId) {
    super(x, y, 5); // üü¢ TH√äM: Radius = 5 ƒë·ªÉ Physics check va ch·∫°m
    this.type = ENTITY_TYPES.PROJECTILE;

    this.x = x;
    this.y = y;
    this.angle = angle;
    this.speed = speed; // üü¢ S·ª¨A: L∆∞u speed g·ªëc (600), KH√îNG nh√¢n 60 n·ªØa
    this.damage = damage;
    this.ownerId = ownerId;
    
    this.createdAt = Date.now();
    this.hit = false;
    this.maxLifetime = 3000; // 3 gi√¢y t·ª± h·ªßy
    
    // ID Random
    this.id = Math.random().toString(36).substr(2, 9);
  }

  // üü¢ QUAN TR·ªåNG: Ph·∫£i c√≥ h√†m n√†y ƒë·∫°n m·ªõi bay ƒë∆∞·ª£c
  update(dt) {
    const moveDist = this.speed * dt; // T·ªëc ƒë·ªô * Th·ªùi gian tr√¥i qua

    this.x += Math.cos(this.angle) * moveDist;
    this.y += Math.sin(this.angle) * moveDist;
  }

  shouldRemove() {
    // X√≥a khi tr√∫ng ƒë√≠ch, h·∫øt th·ªùi gian, ho·∫∑c bay ra kh·ªèi map
    return (
        this.hit || 
        (Date.now() - this.createdAt > this.maxLifetime) ||
        this.x < -MAP_SIZE/2 || this.x > MAP_SIZE/2 ||
        this.y < -MAP_SIZE/2 || this.y > MAP_SIZE/2
    );
  }

  serialize() {
    return {
      id: this.id,
      x: Math.round(this.x),
      y: Math.round(this.y),
      angle: this.angle
    };
  }
}
</file>

<file path="src/index.js">
import { Server } from './core/Server.js';
import express from 'express';
import cors from 'cors';
import { connectDB } from './db/mongo.js';
import authRouter from './api/auth.js';
import config from './config.js';

const app = express();

// Middleware
app.use(cors());
app.use(express.json());

// REST API routes
app.use('/api/auth', authRouter);

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'ok', timestamp: Date.now() });
});

// Start HTTP server
const PORT = config.HTTP_PORT || 8080;
app.listen(PORT, () => {
  console.log(`HTTP API server running on port ${PORT}`);
});

// Connect to MongoDB
connectDB().then(() => {
  console.log('MongoDB connected');
  
  // Start WebSocket game server
  const gameServer = new Server(config.WS_PORT || 3000);
  gameServer.start();
}).catch(err => {
  console.error('Failed to connect to MongoDB:', err);
  process.exit(1);
});
</file>

<file path="src/utils/Quadtree.js">
// server/src/utils/Quadtree.js

export class Quadtree {
  constructor(boundary, capacity) {
    this.boundary = boundary; // { x, y, width, height } (t√≠nh t·ª´ t√¢m)
    this.capacity = capacity; // S·ªë l∆∞·ª£ng ƒëi·ªÉm t·ªëi ƒëa tr∆∞·ªõc khi chia nh·ªè
    this.points = [];
    this.divided = false;
  }

  // Chia nh·ªè node th√†nh 4 ph·∫ßn
  subdivide() {
    const { x, y, width, height } = this.boundary;
    const w = width / 2;
    const h = height / 2;

    this.northeast = new Quadtree({ x: x + w, y: y - h, width: w, height: h }, this.capacity);
    this.northwest = new Quadtree({ x: x - w, y: y - h, width: w, height: h }, this.capacity);
    this.southeast = new Quadtree({ x: x + w, y: y + h, width: w, height: h }, this.capacity);
    this.southwest = new Quadtree({ x: x - w, y: y + h, width: w, height: h }, this.capacity);
    
    this.divided = true;
  }

  // Th√™m m·ªôt entity v√†o Quadtree
  insert(point) {
    // point ph·∫£i c√≥ d·∫°ng { x, y, userData }
    if (!this.contains(this.boundary, point)) {
      return false;
    }

    if (this.points.length < this.capacity) {
      this.points.push(point);
      return true;
    }

    if (!this.divided) {
      this.subdivide();
    }

    return (
      this.northeast.insert(point) ||
      this.northwest.insert(point) ||
      this.southeast.insert(point) ||
      this.southwest.insert(point)
    );
  }

  // T√¨m c√°c ƒëi·ªÉm trong khu v·ª±c range
  query(range, found) {
    if (!found) found = [];

    if (!this.intersects(this.boundary, range)) {
      return found;
    }

    for (let p of this.points) {
      if (this.contains(range, p)) {
        found.push(p);
      }
    }

    if (this.divided) {
      this.northeast.query(range, found);
      this.northwest.query(range, found);
      this.southeast.query(range, found);
      this.southwest.query(range, found);
    }

    return found;
  }

  // Helpers h√¨nh h·ªçc
  contains(rect, point) {
    return (
      point.x >= rect.x - rect.width &&
      point.x <= rect.x + rect.width &&
      point.y >= rect.y - rect.height &&
      point.y <= rect.y + rect.height
    );
  }

  intersects(rectA, rectB) {
    return !(
      rectB.x - rectB.width > rectA.x + rectA.width ||
      rectB.x + rectB.width < rectA.x - rectA.width ||
      rectB.y - rectB.height > rectA.y + rectA.height ||
      rectB.y + rectB.height < rectA.y - rectA.height
    );
  }
}
</file>

</files>
