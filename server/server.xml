This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.env.example
package.json
src/api/auth.js
src/config.js
src/core/Game.js
src/core/Physics.js
src/core/Server.js
src/db/models/User.model.js
src/db/mongo.js
src/entities/Chest.js
src/entities/Entity.js
src/entities/Explosion.js
src/entities/Item.js
src/entities/Player.js
src/entities/Projectile.js
src/index.js
src/utils/Quadtree.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="package.json">
{
  "name": "server",
  "version": "1.0.0",
  "type": "module",
  "main": "src/index.js",
  "scripts": {
    "dev": "nodemon src/index.js",
    "start": "node src/index.js"
  },
  "dependencies": {
    "ws": "^8.16.0",
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "mongoose": "^8.0.3",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.2",
    "io-game-shared": "../shared"
  },
  "devDependencies": {
    "nodemon": "^3.0.2"
  }
}
</file>

<file path="src/api/auth.js">
import express from 'express';
import jwt from 'jsonwebtoken';
// L∆∞u √Ω: ƒê∆∞·ªùng d·∫´n n√†y ƒë√£ ƒë∆∞·ª£c s·ª≠a ƒë·ªÉ ƒë√∫ng v·ªõi c·∫•u tr√∫c models
import { User } from '../db/models/User.model.js';
import config from '../config.js';

const router = express.Router();

// Register
router.post('/register', async (req, res) => {
  try {
    const { username, email, password } = req.body;

    // Validation
    if (!username || !email || !password) {
      return res.status(400).json({ error: 'All fields required' });
    }

    // Check if user exists
    const existingUser = await User.findOne({ 
      $or: [{ username }, { email }] 
    });
    
    if (existingUser) {
      return res.status(400).json({ error: 'User already exists' });
    }

    // Create user
    const user = new User({ username, email, password });
    await user.save();

    // Generate token
    const token = jwt.sign({ id: user._id }, config.JWT_SECRET, {
      expiresIn: '7d'
    });

    res.status(201).json({
      token,
      user: {
        id: user._id,
        username: user.username,
        email: user.email,
        highScore: user.highScore
      }
    });
  } catch (error) {
    console.error('Register error:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

// Login
router.post('/login', async (req, res) => {
  try {
    const { username, password } = req.body;

    // Find user
    const user = await User.findOne({ username });
    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Check password
    const isMatch = await user.comparePassword(password);
    if (!isMatch) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Generate token
    const token = jwt.sign({ id: user._id }, config.JWT_SECRET, {
      expiresIn: '7d'
    });

    res.json({
      token,
      user: {
        id: user._id,
        username: user.username,
        email: user.email,
        highScore: user.highScore,
        coins: user.coins
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

// Get profile (protected route)
router.get('/profile', async (req, res) => {
  try {
    const token = req.headers.authorization?.split(' ')[1];
    if (!token) {
      return res.status(401).json({ error: 'No token provided' });
    }

    const decoded = jwt.verify(token, config.JWT_SECRET);
    const user = await User.findById(decoded.id).select('-password');
    
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    res.json({ user });
  } catch (error) {
    res.status(401).json({ error: 'Invalid token' });
  }
});

export default router;
</file>

<file path="src/config.js">
import dotenv from 'dotenv';
dotenv.config();

export default {
  WS_PORT: process.env.WS_PORT || 3000,
  HTTP_PORT: process.env.HTTP_PORT || 8080,
  MONGODB_URI: process.env.MONGODB_URI || 'mongodb://localhost:27017/io-game',
  JWT_SECRET: process.env.JWT_SECRET || 'change-this-secret-key',
  NODE_ENV: process.env.NODE_ENV || 'development'
};
</file>

<file path="src/core/Game.js">
// server/src/core/Game.js

import { TICK_RATE, MAP_SIZE, FOOD_COUNT, OBSTACLE_COUNT, OBSTACLE_RADIUS_MIN, OBSTACLE_RADIUS_MAX, CHEST_COUNT, CHEST_RADIUS, ITEM_TYPES } from '../../../shared/src/constants.js';
import { PacketType } from '../../../shared/src/packetTypes.js';
import { Player } from '../entities/Player.js';
import { Physics } from './Physics.js';
import { Chest } from '../entities/Chest.js';
import { Item } from '../entities/Item.js';

export class Game {
  constructor(server) {
    this.server = server;
    this.players = new Map();
    this.projectiles = [];
    this.explosions = [];
    this.physics = new Physics(this);
    this.tickInterval = null;
    this.lastTick = Date.now();

    // Qu·∫£n l√Ω th·ª©c ƒÉn & Delta
    this.foods = [];
    this.removedFoodIds = [];
    this.newFoods = [];

    this.initFood();

    // Qu·∫£n l√Ω ch∆∞·ªõng ng·∫°i v·∫≠t
    this.obstacles = [];
    this.initObstacles();

    // Qu·∫£n l√Ω Chest
    this.chests = [];
    this.removedChestIds = []; // Delta
    this.newChests = [];       // Delta
    this.initChests();

    // Qu·∫£n l√Ω Items (R∆°i tr√™n ƒë·∫•t)
    this.items = [];
    this.removedItemIds = [];  // Delta
    this.newItems = [];        // Delta
  }

  start() {
    const tickDelay = 1000 / TICK_RATE;
    this.tickInterval = setInterval(() => this.tick(), tickDelay);
    console.log(`Game loop started at ${TICK_RATE} ticks/sec`);
  }

  initFood() {
    for (let i = 0; i < FOOD_COUNT; i++) {
      // Init ban ƒë·∫ßu kh√¥ng c·∫ßn tracking delta
      this.foods.push(this._createFoodObject());
    }
  }

  initObstacles() {
    for (let i = 0; i < OBSTACLE_COUNT; i++) {
      const radius = Math.floor(Math.random() * (OBSTACLE_RADIUS_MAX - OBSTACLE_RADIUS_MIN + 1)) + OBSTACLE_RADIUS_MIN;
      const max = MAP_SIZE / 2 - radius;
      this.obstacles.push({
        id: `obs_${i}`,
        x: (Math.random() * MAP_SIZE) - max,
        y: (Math.random() * MAP_SIZE) - max,
        radius: radius
      });
    }
  }

  initChests() {
    for (let i = 0; i < CHEST_COUNT; i++) {
      this.chests.push(this._spawnRandomChest(`chest_${i}`));
    }
  }

  _spawnRandomChest(id) {
    const max = MAP_SIZE / 2 - CHEST_RADIUS;
    return new Chest(
      (Math.random() * MAP_SIZE) - max,
      (Math.random() * MAP_SIZE) - max,
      id
    );
  }

  _createFoodObject() {
    const max = MAP_SIZE / 2;
    return {
      id: Math.random().toString(36).substr(2, 9),
      x: (Math.random() * MAP_SIZE) - max,
      y: (Math.random() * MAP_SIZE) - max,
      type: Math.floor(Math.random() * 3)
    };
  }

  generateAndTrackFood() {
    const food = this._createFoodObject();
    this.newFoods.push(food);
    return food;
  }

  // üü¢ H√†m t·∫°o item r∆°i ra (ƒë∆∞·ª£c g·ªçi t·ª´ Physics)
  spawnItem(x, y) {
    // Random lo·∫°i item
    const keys = Object.values(ITEM_TYPES);
    const randomType = keys[Math.floor(Math.random() * keys.length)];

    const item = new Item(x, y, randomType);
    this.items.push(item);
    this.newItems.push(item); // B√°o update
  }

  tick() {
    // 1. Reset Delta
    this.removedFoodIds = [];
    this.newFoods = [];
    this.removedChestIds = [];
    this.newChests = [];
    this.removedItemIds = [];
    this.newItems = [];

    const now = Date.now();
    let dt = (now - this.lastTick) / 1000;
    this.lastTick = now;

    if (dt > 0.05) dt = 0.05;

    // 2. Update Projectiles
    for (let i = this.projectiles.length - 1; i >= 0; i--) {
      const proj = this.projectiles[i];
      proj.update(dt);

      // Ki·ªÉm tra range TR∆Ø·ªöC khi shouldRemove
      if (proj.distanceTraveled >= proj.range) {
        if (proj.weaponType === 'ROCKET') {
          console.log(`Rocket reached max range, exploding!`);
          this.physics.createExplosion(proj);
        }
        this.projectiles.splice(i, 1);
        continue;
      }

      if (proj.shouldRemove()) {
        this.projectiles.splice(i, 1);
      }
    }

    // 3. Update Explosions (T·ª± x√≥a sau lifetime)
    for (let i = this.explosions.length - 1; i >= 0; i--) {
      if (this.explosions[i].shouldRemove()) {
        this.explosions.splice(i, 1);
      }
    }

    // 4. Update Players
    this.players.forEach(player => {
      if (!player.dead) {
        player.update(dt);
      }
    });

    // 5. Physics (Check va ch·∫°m)
    this.physics.checkCollisions();

    // 6. Respawn Food
    if (this.foods.length < FOOD_COUNT) {
      this.foods.push(this.generateAndTrackFood());
    }

    // 7. Respawn Chests (N·∫øu b·ªã b·∫Øn v·ª° th√¨ sinh l·∫°i sau frame ƒë√≥ lu√¥n ho·∫∑c delay tu·ª≥ √Ω)
    // ·ªû ƒë√¢y l√†m ƒë∆°n gi·∫£n: thi·∫øu l√† b√π lu√¥n
    while (this.chests.length < CHEST_COUNT) {
      const newChest = this._spawnRandomChest(Math.random().toString(36).substr(2, 9));
      this.chests.push(newChest);
      this.newChests.push(newChest);
    }

    // 8. Send Update
    this.sendStateUpdate();
  }

  addPlayer(clientId, name) {
    const player = new Player(clientId, name);
    this.players.set(clientId, player);

    // G·ª≠i INIT: Full foods + Obstacles
    this.server.sendToClient(clientId, {
      type: PacketType.INIT,
      id: clientId,
      player: player.serialize(),
      players: Array.from(this.players.values()).map(p => p.serialize()),
      foods: this.foods,
      obstacles: this.obstacles,
      chests: this.chests, // G·ª≠i full
      items: this.items    // G·ª≠i full
    });

    this.server.broadcast({
      type: PacketType.PLAYER_JOIN,
      player: player.serialize()
    }, clientId);

    console.log(`Player joined: ${name} (${clientId})`);
  }

  removePlayer(clientId) {
    const player = this.players.get(clientId);
    if (player) {
      this.players.delete(clientId);
      console.log(`Player removed: ${player.name}`);
    }
  }

  handleInput(clientId, inputData) {
    const player = this.players.get(clientId);
    if (player && !player.dead) {
      player.setInput(inputData);
    }
  }

  handleAttack(clientId) {
    const player = this.players.get(clientId);
    if (player && !player.dead) {
      const newProjectiles = player.attack();
      if (newProjectiles) {
        this.projectiles.push(...newProjectiles);
      }
    }
  }

  respawnPlayer(clientId) {
    const player = this.players.get(clientId);
    if (player && player.dead) {
      player.dead = false;
      player.respawn();
    }
  }

  sendStateUpdate() {
    const state = {
      type: PacketType.UPDATE,
      t: Date.now(),
      // QUAN TR·ªåNG: G·ª≠i m·∫£ng players ƒë·ªÉ HUD v·∫Ω Leaderboard
      players: Array.from(this.players.values()).map(p => p.serialize()),
      projectiles: this.projectiles.map(p => p.serialize()),
      explosions: this.explosions.map(e => e.serialize()),
      foodsAdded: this.newFoods,
      foodsRemoved: this.removedFoodIds,
      // Th√™m Delta Chests
      chestsAdded: this.newChests,
      chestsRemoved: this.removedChestIds,
      // Th√™m Delta Items
      itemsAdded: this.newItems,
      itemsRemoved: this.removedItemIds
    };

    this.server.broadcast(state);
  }

  getLeaderboard() {
    return Array.from(this.players.values())
      .sort((a, b) => b.score - a.score)
      .slice(0, 10)
      .map(p => ({ name: p.name, score: p.score }));
  }
}
</file>

<file path="src/core/Physics.js">
import { circleCollision, distance } from '../../../shared/src/utils.js';
import { PLAYER_RADIUS, MAP_SIZE, FOOD_RADIUS, XP_PER_FOOD, CHEST_RADIUS, ITEM_RADIUS, WEAPON_STATS } from '../../../shared/src/constants.js';
import { Quadtree } from '../utils/Quadtree.js';
import { Explosion } from '../entities/Explosion.js';
import { Projectile } from '../entities/Projectile.js';

export class Physics {
  constructor(game) {
    this.game = game;
  }

  checkCollisions() {
    const boundary = { x: 0, y: 0, width: MAP_SIZE, height: MAP_SIZE };
    const qt = new Quadtree(boundary, 4);

    this.game.players.forEach(player => {
      qt.insert({ x: player.x, y: player.y, userData: player });
    });

    // Projectile vs Players
    for (let i = this.game.projectiles.length - 1; i >= 0; i--) {
      const proj = this.game.projectiles[i];
      if (proj.hit) continue;
      const range = {
        x: proj.x, y: proj.y,
        width: PLAYER_RADIUS * 2, height: PLAYER_RADIUS * 2
      };

      const candidates = qt.query(range);
      let hitSomeone = false;

      for (let point of candidates) {
        const player = point.userData;
        if (player.id === proj.ownerId) continue;

        if (circleCollision(player.x, player.y, PLAYER_RADIUS, proj.x, proj.y, proj.radius)) {
          console.log(`HIT! ${proj.weaponType} hit ${player.name}. Damage: ${proj.damage}`);

          // N·∫øu l√† Rocket th√¨ t·∫°o explosion TR∆Ø·ªöC khi x√≥a ƒë·∫°n
          if (proj.weaponType === 'ROCKET') {
            this.createExplosion(proj);
          } else {
            // C√°c v≈© kh√≠ kh√°c th√¨ damage tr·ª±c ti·∫øp
            player.takeDamage(proj.damage, proj.ownerId);
          }

          proj.hit = true;
          hitSomeone = true;

          if (player.isDead()) {
            this.handlePlayerDeath(player, proj.ownerId, proj.ownerName);
          }
          break;
        }
      }

      if (hitSomeone) {
        this.game.projectiles.splice(i, 1);
      }
    }

    // Player vs Player
    this.game.players.forEach(player => {
      if (player.dead) return;
      const range = {
        x: player.x, y: player.y,
        width: player.radius * 2 + 10, height: player.radius * 2 + 10
      };
      const candidates = qt.query(range);
      for (let point of candidates) {
        const other = point.userData;
        if (other.id !== player.id) {
          this.resolvePlayerCollision(player, other);
        }
      }
    });

    // Player vs Food
    this.game.players.forEach(player => {
      if (player.dead) return;
      for (let i = this.game.foods.length - 1; i >= 0; i--) {
        const food = this.game.foods[i];
        const dx = player.x - food.x;
        const dy = player.y - food.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < (player.radius || PLAYER_RADIUS) + FOOD_RADIUS) {
          player.score += XP_PER_FOOD;
          player.checkLevelUp();
          this.game.removedFoodIds.push(food.id);
          this.game.foods.splice(i, 1);
        }
      }
    });

    // Player vs Obstacles
    this.game.players.forEach(player => {
      if (player.dead) return;
      this.game.obstacles.forEach(obs => {
        const dx = player.x - obs.x;
        const dy = player.y - obs.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const minDist = (player.radius || PLAYER_RADIUS) + obs.radius;
        if (dist < minDist) {
          const angle = Math.atan2(dy, dx);
          const pushOut = minDist - dist;
          player.x += Math.cos(angle) * pushOut;
          player.y += Math.sin(angle) * pushOut;
        }
      });
    });

    // Projectile vs Obstacles
    for (let i = this.game.projectiles.length - 1; i >= 0; i--) {
      const proj = this.game.projectiles[i];
      for (const obs of this.game.obstacles) {
        const dx = proj.x - obs.x;
        const dy = proj.y - obs.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < proj.radius + obs.radius) {
          // Rocket n·ªï khi ƒë√¢m v√†o obstacle
          if (proj.weaponType === 'ROCKET') {
            this.createExplosion(proj);
          }
          this.game.projectiles.splice(i, 1);
          break;
        }
      }
    }

    // Projectile vs Chests
    for (let i = this.game.projectiles.length - 1; i >= 0; i--) {
      const proj = this.game.projectiles[i];
      for (let j = this.game.chests.length - 1; j >= 0; j--) {
        const chest = this.game.chests[j];
        if (circleCollision(proj.x, proj.y, proj.radius, chest.x, chest.y, chest.radius)) {
          chest.takeDamage(proj.damage);

          // Rocket n·ªï khi ƒë√°nh tr√∫ng chest
          if (proj.weaponType === 'ROCKET') {
            this.createExplosion(proj);
          }

          this.game.projectiles.splice(i, 1);
          if (chest.dead) {
            this.game.spawnItem(chest.x, chest.y);
            this.game.removedChestIds.push(chest.id);
            this.game.chests.splice(j, 1);
          }
          break;
        }
      }
    }

    // Player vs Items
    this.game.players.forEach(player => {
      if (player.dead) return;
      for (let i = this.game.items.length - 1; i >= 0; i--) {
        const item = this.game.items[i];
        if (circleCollision(player.x, player.y, player.radius, item.x, item.y, ITEM_RADIUS)) {
          player.applyItem(item.type);
          this.game.removedItemIds.push(item.id);
          this.game.items.splice(i, 1);
        }
      }
    });

    // Player vs Chests (Collision)
    this.game.players.forEach(player => {
      if (player.dead) return;
      this.game.chests.forEach(chest => {
        const dx = player.x - chest.x;
        const dy = player.y - chest.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const minDist = player.radius + chest.radius;
        if (dist < minDist) {
          const angle = Math.atan2(dy, dx);
          const pushOut = minDist - dist;
          player.x += Math.cos(angle) * pushOut;
          player.y += Math.sin(angle) * pushOut;
        }
      });
    });
  }

  // H√ÄM T·∫†O EXPLOSION
  createExplosion(projectile) {
  const stats = WEAPON_STATS[projectile.weaponType];
  if (!stats || !stats.shrapnelCount) return;

  console.log(`Rocket exploded! Creating ${stats.shrapnelCount} shrapnel`);

  // T·∫°o 8 m·∫£nh v·ª•n b·∫Øn ra 8 h∆∞·ªõng
  const angleStep = (Math.PI * 2) / stats.shrapnelCount;
  
  for (let i = 0; i < stats.shrapnelCount; i++) {
    const angle = angleStep * i;
    
    const shrapnel = new Projectile(
      projectile.x, projectile.y, angle,
      400, // T·ªëc ƒë·ªô
      stats.shrapnelDamage,
      projectile.ownerId,
      projectile.ownerName,
      'SHRAPNEL',
      150, // Range
      3    // Radius
    );
    
    shrapnel.color = 0xFF6600;
    this.game.projectiles.push(shrapnel);
  }
  
  // T·∫°o visual effect
  const explosion = new Explosion(
    projectile.x, projectile.y,
    stats.explosionRadius, 0,
    projectile.ownerId, projectile.ownerName
  );
  this.game.explosions.push(explosion);
}

  resolvePlayerCollision(p1, p2) {
    const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
    const minDist = (p1.radius || PLAYER_RADIUS) + (p2.radius || PLAYER_RADIUS);
    if (dist < minDist && dist > 0) {
      const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
      const overlap = (minDist - dist) / 2;
      p1.x -= Math.cos(angle) * overlap;
      p1.y -= Math.sin(angle) * overlap;
      p2.x += Math.cos(angle) * overlap;
      p2.y += Math.sin(angle) * overlap;
    }
  }

  handlePlayerDeath(player, killerId, killerName) {
    const killer = this.game.players.get(killerId);
    if (killer) {
      killer.score += 100;
      killer.health = Math.min(killer.health + 20, killer.maxHealth);
    }
    player.dead = true;
    player.health = 0;
    this.game.server.broadcast({
      type: 'player_died',
      victimId: player.id,
      killerId: killerId,
      killerName: killerName || 'Unknown',
      score: player.score
    });
  }
}
</file>

<file path="src/core/Server.js">
import { WebSocketServer } from 'ws';
import { PacketType } from '../../../shared/src/packetTypes.js';
import { Game } from './Game.js';

export class Server {
  constructor(port = 3000) {
    this.wss = new WebSocketServer({ port });
    this.game = new Game(this);
    this.clients = new Map();
    
    console.log(`WebSocket server running on port ${port}`);
    this.setupWSS();
  }

  setupWSS() {
    this.wss.on('connection', (ws) => {
      const clientId = this.generateId();
      console.log(`Client connected: ${clientId}`);
      
      this.clients.set(clientId, { ws, id: clientId, player: null });

      ws.on('message', (data) => {
        try {
          const packet = JSON.parse(data.toString());
          this.handleMessage(clientId, packet);
        } catch (err) {
          console.error('Invalid packet:', err);
        }
      });

      ws.on('close', () => {
        console.log(`Client disconnected: ${clientId}`);
        this.game.removePlayer(clientId);
        this.clients.delete(clientId);
        this.broadcast({ type: PacketType.PLAYER_LEAVE, id: clientId });
      });

      ws.on('error', (err) => console.error('WebSocket error:', err));
    });
  }

  handleMessage(clientId, packet) {
    switch (packet.type) {
      case PacketType.JOIN:
        this.game.addPlayer(clientId, packet.name || 'Anonymous');
        break;
      case PacketType.INPUT:
        this.game.handleInput(clientId, packet.data);
        break;
      case PacketType.ATTACK:
        this.game.handleAttack(clientId);
        break;
      case PacketType.PONG:
        const client = this.clients.get(clientId);
        if (client?.player) {
          client.player.lastPong = Date.now();
        }
        break;
      case PacketType.RESPAWN: 
        this.game.respawnPlayer(clientId);
        break;
    }
  }

  sendToClient(clientId, data) {
    const client = this.clients.get(clientId);
    if (client?.ws.readyState === 1) {
      client.ws.send(JSON.stringify(data));
    }
  }

  broadcast(data, excludeId = null) {
    const message = JSON.stringify(data);
    this.clients.forEach((client, id) => {
      if (id !== excludeId && client.ws.readyState === 1) {
        client.ws.send(message);
      }
    });
  }

  generateId() {
    return Math.random().toString(36).substr(2, 9);
  }

  start() {
    this.game.start();
  }
}
</file>

<file path="src/db/models/User.model.js">
import mongoose from 'mongoose';
import bcrypt from 'bcryptjs';

const userSchema = new mongoose.Schema({
  username: {
    type: String,
    required: true,
    unique: true,
    trim: true,
    minlength: 3,
    maxlength: 20
  },
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true
  },
  password: {
    type: String,
    required: true,
    minlength: 6
  },
  highScore: {
    type: Number,
    default: 0
  },
  totalKills: {
    type: Number,
    default: 0
  },
  totalDeaths: {
    type: Number,
    default: 0
  },
  coins: {
    type: Number,
    default: 0
  },
  skins: {
    type: [String],
    default: ['default']
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

// Hash password before saving
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  
  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error);
  }
});

// Method to compare password
userSchema.methods.comparePassword = async function(candidatePassword) {
  return await bcrypt.compare(candidatePassword, this.password);
};

export const User = mongoose.model('User', userSchema);
</file>

<file path="src/db/mongo.js">
import mongoose from 'mongoose';
import config from '../config.js';

export async function connectDB() {
  try {
    await mongoose.connect(config.MONGODB_URI);
    console.log('MongoDB connected successfully');
  } catch (error) {
    console.error('MongoDB connection error:', error);
    throw error;
  }
}

export default mongoose;
</file>

<file path="src/entities/Chest.js">
export class Chest {
  constructor(x, y, id) {
    this.x = x;
    this.y = y;
    this.id = id;
    this.radius = 25; // Hardcode ho·∫∑c l·∫•y t·ª´ constant
    this.health = 50;
    this.dead = false;
  }

  takeDamage(amount) {
    this.health -= amount;
    if (this.health <= 0) {
      this.health = 0;
      this.dead = true;
    }
  }
}
</file>

<file path="src/entities/Entity.js">
export class Entity {
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
    this.vx = 0;
    this.vy = 0;
  }

  update(dt) {
    this.x += this.vx * dt;
    this.y += this.vy * dt;
  }

  serialize() {
    return {
      x: Math.round(this.x),
      y: Math.round(this.y)
    };
  }
}
</file>

<file path="src/entities/Explosion.js">
// server/src/entities/Explosion.js

export class Explosion {
  constructor(x, y, radius, damage, ownerId, ownerName) {
    this.id = Math.random().toString(36).substr(2, 9);
    this.x = x;
    this.y = y;
    this.radius = radius;
    this.damage = damage;
    this.ownerId = ownerId;
    this.ownerName = ownerName;
    this.createdAt = Date.now();
    this.lifetime = 200; // T·ªìn t·∫°i 200ms ƒë·ªÉ client render
  }

  shouldRemove() {
    return Date.now() - this.createdAt > this.lifetime;
  }

  serialize() {
    return {
      id: this.id,
      x: Math.round(this.x),
      y: Math.round(this.y),
      radius: this.radius
    };
  }
}
</file>

<file path="src/entities/Item.js">
export class Item {
  constructor(x, y, type) {
    this.id = Math.random().toString(36).substr(2, 9);
    this.x = x;
    this.y = y;
    this.type = type; // ITEM_TYPES...
    this.radius = 15;
  }
}
</file>

<file path="src/entities/Player.js">
import { Entity } from './Entity.js';
import {
  PLAYER_SPEED, PLAYER_MAX_HEALTH, MAP_SIZE, PLAYER_RADIUS,
  REGEN_DELAY, REGEN_RATE, DASH_DURATION, DASH_COOLDOWN, DASH_MULTIPLIER,
  WEAPON_STATS, ITEM_TYPES
} from '../../../shared/src/constants.js';
import { getRandomPosition } from '../../../shared/src/utils.js';
import { Projectile } from './Projectile.js';

export class Player extends Entity {
  constructor(id, name) {
    const pos = getRandomPosition(MAP_SIZE);
    super(pos.x, pos.y);

    this.id = id;
    this.name = name;
    this.health = PLAYER_MAX_HEALTH;
    this.maxHealth = PLAYER_MAX_HEALTH;
    this.score = 0;
    this.weapon = 'PISTOL'; // M·∫∑c ƒë·ªãnh
    this.angle = 0;
    this.dead = false;
    this.lastDamageTime = 0;
    this.lastAttack = 0;
    this.radius = PLAYER_RADIUS;

    // Dash logic
    this.dashEndTime = 0;
    this.dashCooldownTime = 0;

    // Qu·∫£n l√Ω Buff
    this.shieldEndTime = 0;    // Th·ªùi gian h·∫øt khi√™n
    this.speedBuffEndTime = 0; // Th·ªùi gian h·∫øt t·ªëc ch·∫°y

    // Tracking movement cho Sniper
    this.lastMoveTime = 0;
    this.isMoving = false;

    // Input (ƒê√£ b·ªè num1, num2, num3)
    this.input = {
      up: false, down: false, left: false, right: false,
      mouseX: 0, mouseY: 0, space: false
    };
  }

  setInput(data) {
    // 1. C·∫≠p nh·∫≠t c√°c ph√≠m di chuy·ªÉn 
    if (data.movement) {
      Object.assign(this.input, data.movement);
    }

    // 2. C·∫≠p nh·∫≠t t·ªça ƒë·ªô chu·ªôt
    if (data.mouseX !== undefined) {
      this.input.mouseX = data.mouseX;
    }

    if (data.mouseY !== undefined) {
      this.input.mouseY = data.mouseY;
    }
  }

  update(dt) {
    if (this.dead) return;

    // 1. X·ª≠ l√Ω Input Dash
    if (this.input.space && Date.now() > this.dashCooldownTime) {
      this.dashEndTime = Date.now() + DASH_DURATION;
      this.dashCooldownTime = Date.now() + DASH_COOLDOWN;
    }

    // 2. T√≠nh to√°n t·ªëc ƒë·ªô
    let currentSpeed = PLAYER_SPEED;

    // Gi·∫£m t·ªëc do k√≠ch th∆∞·ªõc (C√†ng to c√†ng ch·∫≠m)
    const sizeFactor = this.radius / PLAYER_RADIUS;
    currentSpeed = currentSpeed / Math.sqrt(sizeFactor);

    // Buff Dash
    if (Date.now() < this.dashEndTime) {
      currentSpeed *= DASH_MULTIPLIER;
    }

    // Buff Speed (Item)
    if (Date.now() < this.speedBuffEndTime) {
      currentSpeed *= 2;
    }

    // 3. Di chuy·ªÉn 
    let dx = 0;
    let dy = 0;
    if (this.input.up) dy -= 1;
    if (this.input.down) dy += 1;
    if (this.input.left) dx -= 1;
    if (this.input.right) dx += 1;

    if (dx !== 0 || dy !== 0) {
      const length = Math.sqrt(dx * dx + dy * dy);
      dx /= length;
      dy /= length;

      this.x += dx * currentSpeed * dt;
      this.y += dy * currentSpeed * dt;

      // ƒê√°nh d·∫•u ƒëang di chuy·ªÉn
      this.isMoving = true;
      this.lastMoveTime = Date.now();
    } else {
      // ƒê·ª©ng y√™n sau 100ms kh√¥ng nh·∫•n ph√≠m
      if (Date.now() - this.lastMoveTime > 100) {
        this.isMoving = false;
      }
    }

    // 4. G√≥c quay
    this.angle = Math.atan2(this.input.mouseY - this.y, this.input.mouseX - this.x);

    // 5. H·ªìi ph·ª•c & Gi·ªõi h·∫°n map
    this.regenerate(dt);
    this.clampToMap();
  }

  checkLevelUp() {
    const scaleFactor = 1 + (this.score / 500);
    this.radius = PLAYER_RADIUS * scaleFactor;
    if (this.radius > PLAYER_RADIUS * 3) {
      this.radius = PLAYER_RADIUS * 3;
    }
  }

  // H√ÄM QUAN TR·ªåNG: X·ª≠ l√Ω ƒÉn v·∫≠t ph·∫©m
  applyItem(type) {
    switch (type) {
      case ITEM_TYPES.HEALTH_PACK:
        this.health = Math.min(this.health + (this.maxHealth * 0.5), this.maxHealth);
        break;
      case ITEM_TYPES.SHIELD:
        this.shieldEndTime = Date.now() + 5000;
        break;
      case ITEM_TYPES.SPEED:
        this.speedBuffEndTime = Date.now() + 5000;
        break;
      case ITEM_TYPES.WEAPON_ROCKET:
        this.weapon = 'ROCKET';
        break;
      case ITEM_TYPES.WEAPON_SHOTGUN:
        this.weapon = 'SHOTGUN';
        break;
      case ITEM_TYPES.WEAPON_MACHINEGUN:
        this.weapon = 'MACHINEGUN';
        break;
      case ITEM_TYPES.WEAPON_SNIPER: // 
        this.weapon = 'SNIPER';
        break;
      case ITEM_TYPES.WEAPON_PISTOL: // 
        this.weapon = 'PISTOL';
        break;
    }
  }

  attack() {
    const now = Date.now();
    const stats = WEAPON_STATS[this.weapon] || WEAPON_STATS.PISTOL;

    if (now - this.lastAttack < stats.cooldown) return null;

    // KI·ªÇM TRA SNIPER: PH·∫¢I ƒê·ª®NG Y√äN
    if (stats.requireStill && this.isMoving) {
      return null; // Kh√¥ng b·∫Øn ƒë∆∞·ª£c n·∫øu ƒëang di chuy·ªÉn
    }

    this.lastAttack = now;

    const projectiles = [];
    const count = stats.count;
    const spread = stats.spread;

    for (let i = 0; i < count; i++) {
      let angleOffset = 0;
      if (count > 1) {
        angleOffset = -spread / 2 + (spread * i / (count - 1));
      } else {
        angleOffset = (Math.random() - 0.5) * spread;
      }

      const finalAngle = this.angle + angleOffset;

      // T·∫°o projectile v·ªõi ƒë·∫ßy ƒë·ªß th√¥ng tin
      const p = new Projectile(
        this.x, this.y,
        finalAngle,
        stats.speed,
        stats.damage,
        this.id,
        this.name,
        this.weapon,      // Weapon type
        stats.range,      // Range
        stats.radius      // Radius
      );

      p.color = stats.color;
      projectiles.push(p);
    }
    return projectiles;
  }

  takeDamage(amount, attackerId) {
    if (Date.now() < this.shieldEndTime) return;
    this.health -= amount;
    this.lastDamageTime = Date.now();
    if (this.health < 0) this.health = 0;
  }

  isDead() {
    return this.health <= 0;
  }

  respawn() {
    const pos = getRandomPosition(MAP_SIZE);
    this.x = pos.x;
    this.y = pos.y;
    this.health = this.maxHealth;
    this.score = Math.max(0, this.score - 50);
    this.weapon = 'PISTOL';
    this.shieldEndTime = 0;
    this.speedBuffEndTime = 0;
    this.angle = 0;
    this.input = { up: false, down: false, left: false, right: false, mouseX: 0, mouseY: 0, space: false };
    this.dashEndTime = 0;
    this.dashCooldownTime = 0;
    this.lastAttack = 0;
    this.lastDamageTime = 0;
    this.radius = PLAYER_RADIUS;
    this.isMoving = false;
    this.lastMoveTime = 0;
  }

  clampToMap() {
    const max = MAP_SIZE / 2 - 20;
    this.x = Math.max(-max, Math.min(max, this.x));
    this.y = Math.max(-max, Math.min(max, this.y));
  }

  regenerate(dt) {
    if (this.health >= this.maxHealth) {
      this.health = this.maxHealth;
      return;
    }
    if (Date.now() - this.lastDamageTime > REGEN_DELAY) {
      this.health += REGEN_RATE * dt;
      if (this.health > this.maxHealth) {
        this.health = this.maxHealth;
      }
    }
  }

  serialize() {
    return {
      id: this.id,
      name: this.name,
      x: Math.round(this.x),
      y: Math.round(this.y),
      angle: this.angle,
      health: this.health,
      maxHealth: this.maxHealth,
      score: this.score,
      dead: this.dead,
      weapon: this.weapon,
      radius: this.radius,
      hasShield: Date.now() < this.shieldEndTime,
      isSpeedUp: Date.now() < this.speedBuffEndTime,
      isMoving: this.isMoving // G·ª≠i v·ªÅ client ƒë·ªÉ hi·ªÉn th·ªã tr·∫°ng th√°i
    };
  }
}
</file>

<file path="src/entities/Projectile.js">
// server/src/entities/Projectile.js
import { Entity } from './Entity.js';
import { ENTITY_TYPES, MAP_SIZE } from '../../../shared/src/constants.js';

export class Projectile extends Entity {
  constructor(x, y, angle, speed, damage, ownerId, ownerName, weaponType, range, radius) {
    super(x, y, radius);
    this.type = ENTITY_TYPES.PROJECTILE;

    this.x = x;
    this.y = y;
    this.angle = angle;
    this.speed = speed;
    this.damage = damage;
    this.ownerId = ownerId;
    this.ownerName = ownerName;
    this.weaponType = weaponType; // L∆∞u lo·∫°i v≈© kh√≠
    this.range = range;            // T·∫ßm b·∫Øn
    this.radius = radius;          // B√°n k√≠nh ƒë·∫°n
    
    this.startX = x;               // V·ªã tr√≠ b·∫Øt ƒë·∫ßu
    this.startY = y;
    this.distanceTraveled = 0;     // Qu√£ng ƒë∆∞·ªùng ƒë√£ bay
    
    this.createdAt = Date.now();
    this.hit = false;
    this.maxLifetime = 5000; // 5 gi√¢y t·ª± h·ªßy (backup)
    
    this.id = Math.random().toString(36).substr(2, 9);
  }

  update(dt) {
    const moveDist = this.speed * dt;
    
    this.x += Math.cos(this.angle) * moveDist;
    this.y += Math.sin(this.angle) * moveDist;
    
    // T√≠nh qu√£ng ƒë∆∞·ªùng ƒë√£ bay
    this.distanceTraveled += moveDist;
  }

  shouldRemove() {
    // X√≥a khi: tr√∫ng ƒë√≠ch, v∆∞·ª£t range, h·∫øt th·ªùi gian, ho·∫∑c bay ra kh·ªèi map
    return (
      this.hit || 
      this.distanceTraveled >= this.range || // Ki·ªÉm tra range
      (Date.now() - this.createdAt > this.maxLifetime) ||
      this.x < -MAP_SIZE/2 || this.x > MAP_SIZE/2 ||
      this.y < -MAP_SIZE/2 || this.y > MAP_SIZE/2
    );
  }

  serialize() {
    return {
      id: this.id,
      x: Math.round(this.x),
      y: Math.round(this.y),
      angle: this.angle,
      radius: this.radius,          // G·ª≠i radius v·ªÅ client ƒë·ªÉ v·∫Ω
      weaponType: this.weaponType   // G·ª≠i type ƒë·ªÉ client bi·∫øt m√†u/style
    };
  }
}
</file>

<file path="src/index.js">
import { Server } from './core/Server.js';
import express from 'express';
import cors from 'cors';
import { connectDB } from './db/mongo.js';
import authRouter from './api/auth.js';
import config from './config.js';

const app = express();

// Middleware
app.use(cors());
app.use(express.json());

// REST API routes
app.use('/api/auth', authRouter);

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'ok', timestamp: Date.now() });
});

// Start HTTP server
const PORT = config.HTTP_PORT || 8080;
app.listen(PORT, () => {
  console.log(`HTTP API server running on port ${PORT}`);
});

// Connect to MongoDB
connectDB().then(() => {
  console.log('MongoDB connected');
  
  // Start WebSocket game server
  const gameServer = new Server(config.WS_PORT || 3000);
  gameServer.start();
}).catch(err => {
  console.error('Failed to connect to MongoDB:', err);
  process.exit(1);
});
</file>

<file path="src/utils/Quadtree.js">
export class Quadtree {
  constructor(boundary, capacity) {
    this.boundary = boundary; // { x, y, width, height } (t√≠nh t·ª´ t√¢m)
    this.capacity = capacity; // S·ªë l∆∞·ª£ng ƒëi·ªÉm t·ªëi ƒëa tr∆∞·ªõc khi chia nh·ªè
    this.points = [];
    this.divided = false;
  }

  // Chia nh·ªè node th√†nh 4 ph·∫ßn
  subdivide() {
    const { x, y, width, height } = this.boundary;
    const w = width / 2;
    const h = height / 2;

    this.northeast = new Quadtree({ x: x + w, y: y - h, width: w, height: h }, this.capacity);
    this.northwest = new Quadtree({ x: x - w, y: y - h, width: w, height: h }, this.capacity);
    this.southeast = new Quadtree({ x: x + w, y: y + h, width: w, height: h }, this.capacity);
    this.southwest = new Quadtree({ x: x - w, y: y + h, width: w, height: h }, this.capacity);
    
    this.divided = true;
  }

  // Th√™m m·ªôt entity v√†o Quadtree
  insert(point) {
    // point ph·∫£i c√≥ d·∫°ng { x, y, userData }
    if (!this.contains(this.boundary, point)) {
      return false;
    }

    if (this.points.length < this.capacity) {
      this.points.push(point);
      return true;
    }

    if (!this.divided) {
      this.subdivide();
    }

    return (
      this.northeast.insert(point) ||
      this.northwest.insert(point) ||
      this.southeast.insert(point) ||
      this.southwest.insert(point)
    );
  }

  // T√¨m c√°c ƒëi·ªÉm trong khu v·ª±c range
  query(range, found) {
    if (!found) found = [];

    if (!this.intersects(this.boundary, range)) {
      return found;
    }

    for (let p of this.points) {
      if (this.contains(range, p)) {
        found.push(p);
      }
    }

    if (this.divided) {
      this.northeast.query(range, found);
      this.northwest.query(range, found);
      this.southeast.query(range, found);
      this.southwest.query(range, found);
    }

    return found;
  }

  // Helpers h√¨nh h·ªçc
  contains(rect, point) {
    return (
      point.x >= rect.x - rect.width &&
      point.x <= rect.x + rect.width &&
      point.y >= rect.y - rect.height &&
      point.y <= rect.y + rect.height
    );
  }

  intersects(rectA, rectB) {
    return !(
      rectB.x - rectB.width > rectA.x + rectA.width ||
      rectB.x + rectB.width < rectA.x - rectA.width ||
      rectB.y - rectB.height > rectA.y + rectA.height ||
      rectB.y + rectB.height < rectA.y - rectA.height
    );
  }
}
</file>

</files>
