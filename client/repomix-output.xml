This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
eslint.config.js
index.html
package.json
public/vite.svg
README.md
src/App.jsx
src/components/DeathScreen.jsx
src/components/GameCanvas.jsx
src/components/HUD.jsx
src/components/LoginScreen.jsx
src/game/config.js
src/game/scenes/GameScene.js
src/index.css
src/main.jsx
src/network/socket.js
vite.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>client</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
</file>

<file path="package.json">
{
  "name": "client",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "phaser": "^3.90.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "vite": "^7.2.4"
  }
}
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="README.md">
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.
</file>

<file path="src/App.jsx">
import React, { useState, useEffect } from 'react';
import GameCanvas from './components/GameCanvas';
import LoginScreen from './components/LoginScreen';
import HUD from './components/HUD';
import DeathScreen from './components/DeathScreen'; // Import
import { socket } from './network/socket';

function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  const [isDead, setIsDead] = useState(false); // Tr·∫°ng th√°i ch·∫øt
  const [killerName, setKillerName] = useState('');

  useEffect(() => {
    // L·∫Øng nghe s·ª± ki·ªán t·ª´ socket ƒë·ªÉ hi·ªán Death Screen
    const unsubscribe = socket.subscribe((data) => {
      // Khi m√¨nh ch·∫øt
      if (data.type === 'GAME_UPDATE' && data.me && data.me.dead) {
         if (!isDead) setIsDead(true); // Ch·ªâ set 1 l·∫ßn
      }
      
      // Khi m√¨nh h·ªìi sinh (Server g·ª≠i me.dead = false)
      if (data.type === 'GAME_UPDATE' && data.me && !data.me.dead && isDead) {
         setIsDead(false);
         setKillerName('');
      }

      // L·∫•y t√™n k·∫ª gi·∫øt m√¨nh (Optional - X·ª≠ l√Ω packet PLAYER_DIED ri√™ng ·ªü socket.js n·∫øu mu·ªën chu·∫©n h∆°n)
    });
    return () => unsubscribe();
  }, [isDead]);

  return (
    <div className="App" style={{ position: 'relative' }}>
      <GameCanvas />
      
      {!isPlaying && <LoginScreen onJoin={() => setIsPlaying(true)} />}
      
      {/* Khi ƒëang ch∆°i v√† ch∆∞a ch·∫øt th√¨ hi·ªán HUD */}
      {isPlaying && !isDead && <HUD />}

      {/* Khi ch·∫øt th√¨ hi·ªán Death Screen */}
      {isPlaying && isDead && <DeathScreen killerName={killerName} />}
    </div>
  );
}

export default App;
</file>

<file path="src/components/DeathScreen.jsx">
import React from 'react';
import { socket } from '../network/socket';
import { PacketType } from '@shared/packetTypes';

const DeathScreen = ({ killerName }) => {
  const handleRespawn = () => {
    // G·ª≠i l·ªánh h·ªìi sinh l√™n server
    socket.send({ type: PacketType.RESPAWN });
  };

  return (
    <div style={{
      position: 'absolute', top: 0, left: 0, width: '100%', height: '100%',
      background: 'rgba(0,0,0,0.8)',
      display: 'flex', flexDirection: 'column',
      justifyContent: 'center', alignItems: 'center',
      color: 'white', zIndex: 20
    }}>
      <h1 style={{ color: '#FF5252', fontSize: '48px', margin: '0 0 20px 0' }}>YOU DIED</h1>
      <p style={{ fontSize: '20px', marginBottom: '30px' }}>
        Killed by: <strong style={{ color: '#FFD700' }}>{killerName || 'Unknown'}</strong>
      </p>
      
      <button 
        onClick={handleRespawn}
        style={{
          padding: '15px 40px', fontSize: '20px', fontWeight: 'bold',
          background: '#4CAF50', color: 'white', border: 'none',
          borderRadius: '10px', cursor: 'pointer',
          boxShadow: '0 4px 0 #388E3C'
        }}
      >
        PLAY AGAIN
      </button>
    </div>
  );
};

export default DeathScreen;
</file>

<file path="src/components/GameCanvas.jsx">
import React, { useEffect, useRef } from 'react';
import Phaser from 'phaser';
import { gameConfig } from '../game/config';

const GameCanvas = () => {
  const gameRef = useRef(null);

  useEffect(() => {
    // Kh·ªüi t·∫°o Phaser khi component ƒë∆∞·ª£c mount
    if (!gameRef.current) {
      gameRef.current = new Phaser.Game(gameConfig);
    }

    // D·ªçn d·∫πp khi component b·ªã unmount (r·∫•t quan tr·ªçng trong React)
    return () => {
      if (gameRef.current) {
        gameRef.current.destroy(true);
        gameRef.current = null;
      }
    };
  }, []);

  return (
    // Phaser s·∫Ω inject canvas v√†o div n√†y nh·ªù id="game-container"
    <div id="game-container" style={{ width: '100vw', height: '100vh', overflow: 'hidden' }} />
  );
};

export default GameCanvas;
</file>

<file path="src/components/HUD.jsx">
import React, { useEffect, useState } from 'react';
import { socket } from '../network/socket';

const HUD = () => {
  const [stats, setStats] = useState({ health: 100, maxHealth: 100, score: 0 });
  const [leaderboard, setLeaderboard] = useState([]);

  useEffect(() => {
    // ƒêƒÉng k√Ω nh·∫≠n d·ªØ li·ªáu t·ª´ socket
    const unsubscribe = socket.subscribe((data) => {
      if (data.type === 'GAME_UPDATE' && data.me) {
        setStats({
          health: data.me.health,
          maxHealth: data.me.maxHealth,
          score: data.me.score
        });
        
        // L∆∞u √Ω: Logic Leaderboard n√™n ƒë∆∞·ª£c t√≠nh ·ªü server g·ª≠i v·ªÅ s·∫Ω chu·∫©n h∆°n
        // Nh∆∞ng t·∫°m th·ªùi ta c√≥ th·ªÉ l·∫•y danh s√°ch player t·ª´ packet update
      }
    });

    return () => unsubscribe();
  }, []);

  // T√≠nh ph·∫ßn trƒÉm m√°u
  const healthPercent = (stats.health / stats.maxHealth) * 100;

  return (
    <div style={{
      position: 'absolute', top: 0, left: 0, width: '100%', height: '100%',
      pointerEvents: 'none', // ƒê·ªÉ click xuy√™n qua ƒë∆∞·ª£c xu·ªëng game
      padding: '20px',
      boxSizing: 'border-box'
    }}>
      
      {/* 1. THANH M√ÅU & ƒêI·ªÇM (G√≥c tr√°i d∆∞·ªõi) */}
      <div style={{
        position: 'absolute', bottom: '20px', left: '20px',
        background: 'rgba(0,0,0,0.6)', padding: '15px', borderRadius: '10px',
        color: 'white', fontFamily: 'Arial, sans-serif'
      }}>
        <div style={{ marginBottom: '5px', fontSize: '18px', fontWeight: 'bold' }}>
          Score: <span style={{ color: '#FFD700' }}>{stats.score}</span>
        </div>
        
        {/* Thanh m√°u */}
        <div style={{ width: '200px', height: '20px', background: '#333', borderRadius: '10px', overflow: 'hidden', border: '2px solid white' }}>
          <div style={{
            width: `${healthPercent}%`,
            height: '100%',
            background: healthPercent > 50 ? '#4CAF50' : healthPercent > 20 ? '#FFC107' : '#F44336',
            transition: 'width 0.2s'
          }} />
        </div>
        <div style={{ fontSize: '12px', marginTop: '5px', textAlign: 'center' }}>
          HP: {Math.round(stats.health)} / {stats.maxHealth}
        </div>
      </div>

      {/* 2. LEADERBOARD (G√≥c ph·∫£i tr√™n) */}
      <div style={{
        position: 'absolute', top: '20px', right: '20px',
        background: 'rgba(0,0,0,0.6)', padding: '15px', borderRadius: '10px',
        color: 'white', minWidth: '150px'
      }}>
        <h3 style={{ margin: '0 0 10px 0', borderBottom: '1px solid #555', paddingBottom: '5px', color: '#FFD700' }}>
          Top Players
        </h3>
        {/* T·∫°m th·ªùi hi·ªÉn th·ªã placeholder */}
        <div style={{ fontSize: '14px', color: '#aaa' }}>Processing...</div>
      </div>

    </div>
  );
};

export default HUD;
</file>

<file path="src/components/LoginScreen.jsx">
import React, { useState } from 'react';
import { socket } from '../network/socket';

const LoginScreen = ({ onJoin }) => {
  const [username, setUsername] = useState('');
  const [connecting, setConnecting] = useState(false);

  const handlePlay = async () => {
    if (!username) return;
    setConnecting(true);
    try {
      await socket.connect(username);
      onJoin(); // B√°o cho App bi·∫øt ƒë√£ k·∫øt n·ªëi xong
    } catch (err) {
      alert('Kh√¥ng th·ªÉ k·∫øt n·ªëi Server!');
      setConnecting(false);
    }
  };

  return (
    <div style={{
      position: 'absolute', top: 0, left: 0, width: '100%', height: '100%',
      display: 'flex', justifyContent: 'center', alignItems: 'center',
      background: 'rgba(0,0,0,0.8)', zIndex: 10
    }}>
      <div style={{
        background: '#fff', padding: '40px', borderRadius: '10px', textAlign: 'center'
      }}>
        <h1 style={{color: '#333'}}>IO GAME REACT</h1>
        <input 
          type="text" 
          placeholder="Nh·∫≠p t√™n..." 
          value={username}
          onChange={(e) => setUsername(e.target.value)}
          onKeyDown={(e) => e.stopPropagation()}
          style={{ padding: '10px', fontSize: '16px', marginBottom: '10px' }}
        />
        <br />
        <button 
          onClick={handlePlay} 
          disabled={connecting}
          style={{ padding: '10px 30px', background: '#4CAF50', color: 'white', border: 'none', cursor: 'pointer' }}
        >
          {connecting ? 'ƒêang k·∫øt n·ªëi...' : 'CH∆†I NGAY'}
        </button>
      </div>
    </div>
  );
};

export default LoginScreen;
</file>

<file path="src/game/config.js">
import Phaser from 'phaser';
import { GameScene } from './scenes/GameScene';

export const gameConfig = {
  type: Phaser.AUTO,
  width: window.innerWidth,
  height: window.innerHeight,
  parent: 'game-container', // ID c·ªßa th·∫ª DIV trong React
  backgroundColor: '#1a1a1a',
  physics: {
    default: 'arcade',
    arcade: {
      debug: false, // B·∫≠t true ƒë·ªÉ xem hitbox
    },
  },
  scene: [GameScene], // Danh s√°ch c√°c m√†n ch∆°i
  scale: {
    mode: Phaser.Scale.RESIZE,
    autoCenter: Phaser.Scale.CENTER_BOTH
  }
};
</file>

<file path="src/game/scenes/GameScene.js">
import Phaser from 'phaser';
import { socket } from '../../network/socket';
import { PacketType } from '@shared/packetTypes';

export class GameScene extends Phaser.Scene {
    constructor() {
        super('GameScene');
        this.players = {}; // L∆∞u danh s√°ch ng∆∞·ªùi ch∆°i: { id: Sprite }
        this.keys = null;  // B√†n ph√≠m
        this.projectileGroup = null; // L∆∞u danh s√°ch ƒë·∫°n: { id: Sprite }
        this.foodGroup = null; // L∆∞u danh s√°ch th·ª©c ƒÉn: { id: Sprite }
    }

    create() {
        // 1. G·∫Øn scene n√†y v√†o socket ƒë·ªÉ nh·∫≠n d·ªØ li·ªáu
        socket.setGameScene(this);

        // 2. T·∫°o background l∆∞·ªõi
        this.add.grid(0, 0, 5000, 5000, 100, 100, 0x1a1a1a, 1, 0x2a2a2a, 1);

        // 3. C√†i ƒë·∫∑t b√†n ph√≠m
        this.keys = this.input.keyboard.addKeys('W,A,S,D,UP,LEFT,DOWN,RIGHT, SPACE');

        this.projectileGroup = this.add.group(); // T·∫°o Group ch·ª©a ƒë·∫°n

        this.foodGroup = this.add.group(); // T·∫°o Group ch·ª©a th·ª©c ƒÉn

        // 4. X·ª≠ l√Ω chu·ªôt (B·∫Øn)
        this.input.on('pointerdown', (pointer) => {
            console.log('üñ±Ô∏è Mouse Clicked at:', pointer.worldX, pointer.worldY);
            socket.send({ type: PacketType.ATTACK });
        });

        console.log('üéÆ GameScene Created. Waiting for server...');
    }

    update() {
        // G·ª≠i Input l√™n Server m·ªói frame (ho·∫∑c throttle n·∫øu c·∫ßn)
        if (!socket.isConnected) return;

        const inputData = {
            movement: {
                up: this.keys.W.isDown || this.keys.UP.isDown,
                down: this.keys.S.isDown || this.keys.DOWN.isDown,
                left: this.keys.A.isDown || this.keys.LEFT.isDown,
                right: this.keys.D.isDown || this.keys.RIGHT.isDown,
                space: this.keys.SPACE.isDown
            },
            // Chuy·ªÉn t·ªça ƒë·ªô chu·ªôt tr√™n m√†n h√¨nh sang t·ªça ƒë·ªô th·∫ø gi·ªõi trong game
            mouseX: this.input.activePointer.worldX,
            mouseY: this.input.activePointer.worldY
        };

        socket.send({ type: PacketType.INPUT, data: inputData });
    }

    // --- C√ÅC H√ÄM X·ª¨ L√ù T·ª™ SOCKET G·ªåI SANG ---

    initGame(data) {
        if (data.players) {
            data.players.forEach(p => this.addPlayer(p));
        }

        // Camera ƒëi theo Container c·ªßa m√¨nh
        if (this.players[data.id]) {
            this.cameras.main.startFollow(this.players[data.id].container);
        }
    }

    handleServerUpdate(packet) {
        // 1. C·∫≠p nh·∫≠t Players (Gi·ªØ nguy√™n)
        if (packet.players) {
            packet.players.forEach(p => {
                const entity = this.players[p.id];
                if (entity) {
                    entity.container.x = p.x;
                    entity.container.y = p.y;
                    entity.container.rotation = p.angle;
                    entity.text.x = p.x;
                    entity.text.y = p.y - 40;
                    // üü¢ TH√äM: ·∫®n hi·ªán nh√¢n v·∫≠t d·ª±a tr√™n tr·∫°ng th√°i dead
                    entity.container.setVisible(!p.dead);
                    entity.text.setVisible(!p.dead);

                    if (!p.dead) {
                        // Ch·ªâ c·∫≠p nh·∫≠t v·ªã tr√≠ n·∫øu c√≤n s·ªëng
                        entity.container.x = p.x;
                        entity.container.y = p.y;
                        entity.container.rotation = p.angle;
                        entity.text.x = p.x;
                        entity.text.y = p.y - 40;
                    }
                    // üü¢ TH√äM: Logic Scale (L·ªõn l√™n)
                    // Gi·∫£ s·ª≠ b√°n k√≠nh g·ªëc l√† 20. Scale = radius_m·ªõi / 20
                    if (p.radius) {
                        const defaultRadius = 20;
                        const scale = p.radius / defaultRadius;

                        // Scale c·∫£ container (c·∫£ ng∆∞·ªùi l·∫´n s√∫ng s·∫Ω to l√™n)
                        entity.container.setScale(scale);
                    }
                } else {
                    this.addPlayer(p);
                }
            });
        }

        // 2. C·∫≠p nh·∫≠t Food (üü¢ TH√äM M·ªöI)
        if (packet.foods) {
            // C√°ch ƒë∆°n gi·∫£n nh·∫•t (X√≥a h·∫øt v·∫Ω l·∫°i - nh∆∞ Projectiles)
            this.foodGroup.clear(true, true);

            packet.foods.forEach(f => {
                // V·∫Ω th·ª©c ƒÉn l√† h√¨nh tr√≤n nh·ªè (ho·∫∑c Sprite n·∫øu b·∫°n mu·ªën)
                let color = 0xFFFFFF;
                if (f.type === 0) color = 0xFF0000; // ƒê·ªè
                if (f.type === 1) color = 0x00FF00; // Xanh
                if (f.type === 2) color = 0x0000FF; // Lam

                const food = this.add.circle(f.x, f.y, 5, color);
                this.foodGroup.add(food);
            });
        }

        // 3. C·∫≠p nh·∫≠t Projectiles (ƒê·∫°n) - D√πng c√°ch "X√≥a ƒëi v·∫Ω l·∫°i"
        if (packet.projectiles) {
            // X√≥a s·∫°ch ƒë·∫°n c≈© (true, true ƒë·ªÉ x√≥a c·∫£ GameObject l·∫´n Physics body n·∫øu c√≥)
            this.projectileGroup.clear(true, true);

            // V·∫Ω l·∫°i to√†n b·ªô ƒë·∫°n m·ªõi t·ª´ server
            packet.projectiles.forEach(p => {
                const bullet = this.add.circle(p.x, p.y, 8, 0xFFFF00); // ƒê·∫°n m√†u v√†ng
                this.projectileGroup.add(bullet);
            });
        }
    }
    addPlayer(playerData) {
        if (this.players[playerData.id]) return;

        // --- PH·∫¶N 1: T·∫†O NH√ÇN V·∫¨T (XOAY ƒê∆Ø·ª¢C) ---
        const container = this.add.container(playerData.x, playerData.y);

        // M√†u: M√¨nh m√†u xanh, ƒë·ªãch m√†u ƒë·ªè
        const color = (playerData.id === socket.myId) ? 0x4CAF50 : 0xE53935;
        const circle = this.add.circle(0, 0, 20, color);
        const weapon = this.add.rectangle(15, 0, 20, 8, 0xFFFFFF); // S√∫ng

        container.add([weapon, circle]);
        container.setDepth(1); // ƒê·ªô s√¢u th·∫•p h∆°n ch·ªØ

        // --- PH·∫¶N 2: T·∫†O T√äN (KH√îNG XOAY, LU√îN ·ªû TR√äN ƒê·∫¶U) ---
        // T·∫°o text ri√™ng bi·ªát, KH√îNG add v√†o container
        const nameText = this.add.text(playerData.x, playerData.y - 40, playerData.name, {
            fontSize: '14px',
            color: '#FFFFFF',
            stroke: '#000000', // Th√™m vi·ªÅn ƒëen cho d·ªÖ nh√¨n
            strokeThickness: 3
        }).setOrigin(0.5);

        nameText.setDepth(2); // Lu√¥n n·ªïi l√™n tr√™n c√πng

        // --- PH·∫¶N 3: L∆ØU TR·ªÆ ---
        // L∆∞u c·∫£ 2 v√†o object ƒë·ªÉ qu·∫£n l√Ω
        this.players[playerData.id] = {
            container: container,
            text: nameText
        };
    }

    removePlayer(id) {
        if (this.players[id]) {
            this.players[id].container.destroy(); // X√≥a nh√¢n v·∫≠t
            this.players[id].text.destroy();      // X√≥a t√™n
            delete this.players[id];
        }
    }
}
</file>

<file path="src/index.css">
body {
  margin: 0;
  padding: 0;
  overflow: hidden; /* ·∫®n thanh cu·ªôn */
  background-color: #000;
}
</file>

<file path="src/main.jsx">
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.jsx'

createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
</file>

<file path="src/network/socket.js">
import { PacketType } from '@shared/packetTypes';

class NetworkManager {
  constructor() {
    this.ws = null;
    this.gameScene = null; // Tham chi·∫øu ƒë·∫øn Phaser Scene
    this.myId = null;
    this.isConnected = false;
    this.listeners = [];
  }

  connect(username) {
    return new Promise((resolve, reject) => {
      this.ws = new WebSocket('ws://localhost:3000');

      this.ws.onopen = () => {
        this.isConnected = true;
        console.log('‚úÖ Connected via WebSocket');
        
        // G·ª≠i g√≥i tin JOIN ngay khi k·∫øt n·ªëi
        this.send({ type: PacketType.JOIN, name: username });
        resolve();
      };

      this.ws.onerror = (err) => {
        console.error('‚ùå WebSocket error', err);
        reject(err);
      };

      this.ws.onmessage = (event) => this.handleMessage(event);
      
      this.ws.onclose = () => {
        this.isConnected = false;
        console.log('üîå Disconnected');
      };
    });
  }

  setGameScene(scene) {
    this.gameScene = scene;
  }

  send(data) {
    if (this.isConnected && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(data));
    }
  }

  subscribe(callback) {
    this.listeners.push(callback);
    // Tr·∫£ v·ªÅ h√†m cleanup
    return () => {
      this.listeners = this.listeners.filter(l => l !== callback);
    };
  }

  handleMessage(event) {
    const packet = JSON.parse(event.data);

    // 1. X·ª≠ l√Ω c√°c g√≥i tin Logic Game (chuy·ªÉn cho Phaser)
    if (this.gameScene) {
      switch (packet.type) {
        case PacketType.UPDATE:
          this.gameScene.handleServerUpdate(packet);
          // T√¨m th√¥ng tin c·ªßa m√¨nh ƒë·ªÉ c·∫≠p nh·∫≠t m√°u/ƒëi·ªÉm
          const myData = packet.players.find(p => p.id === this.myId);
          this.notifyReact({ 
            type: 'GAME_UPDATE', 
            me: myData, 
            leaderboard: this.gameScene.getLeaderboard ? this.gameScene.getLeaderboard() : [] 
          });
          break;
        case PacketType.INIT:
          this.myId = packet.id;
          this.gameScene.initGame(packet);
          break;
        case PacketType.PLAYER_JOIN:
          this.gameScene.addPlayer(packet.player);
          break;
        case PacketType.PLAYER_LEAVE:
          this.gameScene.removePlayer(packet.id);
          break;
      }
    }

    // 2. X·ª≠ l√Ω Ping/Pong (t·ª± ƒë·ªông)
    if (packet.type === PacketType.PING) {
      this.send({ type: PacketType.PONG });
    }
  }
  notifyReact(data) {
    this.listeners.forEach(callback => callback(data));
  }
}

// Xu·∫•t ra m·ªôt instance duy nh·∫•t (Singleton) ƒë·ªÉ d√πng chung
export const socket = new NetworkManager();
</file>

<file path="vite.config.js">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    fs: {
      // Cho ph√©p Vite truy c·∫≠p v√†o th∆∞ m·ª•c c·∫•p cao h∆°n (ƒë·ªÉ ƒë·ªçc folder shared)
      allow: ['..'] 
    }
  },
  resolve: {
    alias: {
      // T·∫°o ƒë∆∞·ªùng d·∫´n t·∫Øt '@shared' ƒë·ªÉ import cho g·ªçn
      '@shared': path.resolve(__dirname, '../shared/src') 
    }
  }
})
</file>

</files>
