This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
eslint.config.js
index.html
package.json
public/vite.svg
README.md
src/App.jsx
src/components/DeathScreen.jsx
src/components/GameCanvas.jsx
src/components/HUD.jsx
src/components/LoginScreen.jsx
src/game/config.js
src/game/entities/ClientPlayer.js
src/game/scenes/GameScene.js
src/index.css
src/main.jsx
src/network/socket.js
vite.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>client</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
</file>

<file path="package.json">
{
  "name": "client",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "phaser": "^3.90.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "vite": "^7.2.4"
  }
}
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="README.md">
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.
</file>

<file path="src/App.jsx">
import React, { useState, useEffect } from 'react';
import GameCanvas from './components/GameCanvas';
import LoginScreen from './components/LoginScreen';
import HUD from './components/HUD';
import DeathScreen from './components/DeathScreen';
import { socket } from './network/socket';
import { PacketType } from '@shared/packetTypes';

function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  const [isDead, setIsDead] = useState(false);
  const [killerName, setKillerName] = useState('');
  const [finalScore, setFinalScore] = useState(0);

  const handleQuitToMenu = () => {
    setIsDead(false);
    setKillerName('');
    setFinalScore(0);
    setIsPlaying(false);
  };

  useEffect(() => {
    // L·∫Øng nghe s·ª± ki·ªán t·ª´ socket ƒë·ªÉ hi·ªán Death Screen
    const unsubscribe = socket.subscribe((data) => {
      // Khi m√¨nh ch·∫øt - Server g·ª≠i PLAYER_DIED
      if (data.type === PacketType.PLAYER_DIED && data.victimId === socket.myId) {
        setIsDead(true);
        // L·∫•y t√™n k·∫ª gi·∫øt m√¨nh (n·∫øu c√≥)
        const killer = data.killerName || 'Unknown';
        setKillerName(killer);
        // L·∫•y score tr∆∞·ªõc khi ch·∫øt
        const score = data.score || 0;
        setFinalScore(score);
      }

      // Khi h·ªìi sinh (nh·∫≠n UPDATE t·ª´ server v·ªõi player alive)
      if (data.type === PacketType.UPDATE && isDead) {
        // T√¨m m√¨nh trong danh s√°ch players
        const me = data.players?.find(p => p.id === socket.myId);
        if (me && !me.dead) {
          setIsDead(false);
          setKillerName('');
        }
      }
    });
    return () => unsubscribe();
  }, [isDead]);

  return (
    <div className="App" style={{ position: 'relative' }}>
      <GameCanvas />
      
      {!isPlaying && <LoginScreen onJoin={() => setIsPlaying(true)} />}
      
      {/* Khi ƒëang ch∆°i v√† ch∆∞a ch·∫øt th√¨ hi·ªán HUD */}
      {isPlaying && !isDead && <HUD />}

      {/* Khi ch·∫øt th√¨ hi·ªán Death Screen */}
      {isPlaying && isDead && <DeathScreen killerName={killerName} score={finalScore} onQuit={handleQuitToMenu} />}
    </div>
  );
}

export default App;
</file>

<file path="src/components/DeathScreen.jsx">
import React from 'react';
import { socket } from '../network/socket';
import { PacketType } from '@shared/packetTypes';

const DeathScreen = ({ killerName, score, onQuit }) => {
  const handleRespawn = () => {
    // G·ª≠i l·ªánh h·ªìi sinh l√™n server
    socket.send({ type: PacketType.RESPAWN });
  };

  return (
    <div style={{
      position: 'absolute', top: 0, left: 0, width: '100%', height: '100%',
      background: 'rgba(0,0,0,0.8)',
      display: 'flex', flexDirection: 'column',
      justifyContent: 'center', alignItems: 'center',
      color: 'white', zIndex: 20
    }}>
      <h1 style={{ color: '#FF5252', fontSize: '48px', margin: '0 0 20px 0' }}>YOU DIED</h1>
      <p style={{ fontSize: '20px', marginBottom: '15px' }}>
        Final Score: <strong style={{ color: '#FFD700' }}>{score}</strong>
      </p>
      <p style={{ fontSize: '20px', marginBottom: '30px' }}>
        Killed by: <strong style={{ color: '#FFD700' }}>{killerName || 'Unknown'}</strong>
      </p>
      
      <div style={{ display: 'flex', gap: '20px' }}>
        <button 
          onClick={handleRespawn}
          style={{
            padding: '15px 40px', fontSize: '20px', fontWeight: 'bold',
            background: '#4CAF50', color: 'white', border: 'none',
            borderRadius: '10px', cursor: 'pointer',
            boxShadow: '0 4px 0 #388E3C'
          }}
        >
          PLAY AGAIN
        </button>

        <button 
          onClick={onQuit}
          style={{
            padding: '15px 40px', fontSize: '20px', fontWeight: 'bold',
            background: '#FF6B6B', color: 'white', border: 'none',
            borderRadius: '10px', cursor: 'pointer',
            boxShadow: '0 4px 0 #CC5555'
          }}
        >
          BACK TO MENU
        </button>
      </div>
    </div>
  );
};

export default DeathScreen;
</file>

<file path="src/components/GameCanvas.jsx">
import React, { useEffect, useRef } from 'react';
import Phaser from 'phaser';
import { gameConfig } from '../game/config';

const GameCanvas = () => {
  const gameRef = useRef(null);

  useEffect(() => {
    // Kh·ªüi t·∫°o Phaser khi component ƒë∆∞·ª£c mount
    if (!gameRef.current) {
      gameRef.current = new Phaser.Game(gameConfig);
    }

    // D·ªçn d·∫πp khi component b·ªã unmount (r·∫•t quan tr·ªçng trong React)
    return () => {
      if (gameRef.current) {
        gameRef.current.destroy(true);
        gameRef.current = null;
      }
    };
  }, []);

  return (
    // Phaser s·∫Ω inject canvas v√†o div n√†y nh·ªù id="game-container"
    <div id="game-container" style={{ width: '100vw', height: '100vh', overflow: 'hidden' }} />
  );
};

export default GameCanvas;
</file>

<file path="src/components/HUD.jsx">
import React, { useEffect, useState } from 'react';
import { socket } from '../network/socket';
import { MAP_SIZE } from '@shared/constants'; // Import MAP_SIZE t·ª´ shared

const MINIMAP_SIZE = 150; // K√≠ch th∆∞·ªõc Minimap

const HUD = () => {
  // State ch·ªâ s·ªë
  const [stats, setStats] = useState({ health: 100, maxHealth: 100, score: 0 });
  const [leaderboard, setLeaderboard] = useState([]);
  const [isConnected, setIsConnected] = useState(false);

  // State v·ªã tr√≠ cho Minimap
  const [myPos, setMyPos] = useState({ x: 0, y: 0 });
  const [kingPos, setKingPos] = useState(null);

  useEffect(() => {
    const unsubscribe = socket.subscribe((packet) => {
      setIsConnected(true);

      if (packet.players) {
        // 1. T√¨m b·∫£n th√¢n
        const myId = socket.myId;
        const me = packet.players.find(p => p.id === myId);

        if (me) {
          setStats({
            health: me.health,
            maxHealth: me.maxHealth,
            score: me.score
          });
          // C·∫≠p nh·∫≠t v·ªã tr√≠ m√¨nh
          setMyPos({ x: me.x, y: me.y });
        }

        // 2. C·∫≠p nh·∫≠t Leaderboard & t√¨m King
        const sorted = [...packet.players].sort((a, b) => b.score - a.score);
        setLeaderboard(sorted.slice(0, 10));

        if (sorted.length > 0) {
            setKingPos({ x: sorted[0].x, y: sorted[0].y });
        }
      }
    });

    return () => unsubscribe();
  }, []);

  // üü¢ H√ÄM QUAN TR·ªåNG: Chuy·ªÉn ƒë·ªïi t·ªça ƒë·ªô World -> Minimap
  // (ƒê√¢y l√† c√°i b·∫°n b·ªã thi·∫øu g√¢y ra l·ªói myMinimapPos is not defined)
  const worldToMinimap = (x, y) => {
      const shiftedX = x + (MAP_SIZE / 2);
      const shiftedY = y + (MAP_SIZE / 2);
      
      const ratioX = shiftedX / MAP_SIZE;
      const ratioY = shiftedY / MAP_SIZE;

      return {
          left: ratioX * MINIMAP_SIZE,
          top: ratioY * MINIMAP_SIZE
      };
  };

  // T√≠nh to√°n hi·ªÉn th·ªã
  const healthPercent = stats.maxHealth > 0 ? Math.max(0, (stats.health / stats.maxHealth) * 100) : 0;
  
  const myMinimapPos = worldToMinimap(myPos.x, myPos.y); 
  const kingMinimapPos = kingPos ? worldToMinimap(kingPos.x, kingPos.y) : null;

  return (
    <div style={{
      position: 'absolute', top: 0, left: 0, width: '100%', height: '100%',
      pointerEvents: 'none', padding: '20px', boxSizing: 'border-box', fontFamily: 'Arial, sans-serif'
    }}>
      
      {/* 1. THANH M√ÅU & ƒêI·ªÇM (G√≥c tr√°i d∆∞·ªõi) */}
      <div style={{
        position: 'absolute', bottom: '20px', left: '20px',
        background: 'rgba(0,0,0,0.6)', padding: '15px', borderRadius: '10px',
        color: 'white', border: '1px solid rgba(255,255,255,0.1)'
      }}>
        <div style={{ marginBottom: '5px', fontSize: '18px', fontWeight: 'bold' }}>
          Score: <span style={{ color: '#FFD700' }}>{stats.score}</span>
        </div>
        <div style={{ width: '200px', height: '20px', background: '#333', borderRadius: '10px', overflow: 'hidden', border: '2px solid #555', position: 'relative' }}>
          <div style={{ width: `${healthPercent}%`, height: '100%', background: healthPercent > 50 ? '#4CAF50' : healthPercent > 20 ? '#FFC107' : '#F44336', transition: 'width 0.2s ease-out' }} />
          <div style={{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '12px', fontWeight: 'bold', textShadow: '1px 1px 2px black' }}>
            {Math.round(stats.health)} / {stats.maxHealth}
          </div>
        </div>
      </div>

      {/* 2. LEADERBOARD (G√≥c ph·∫£i tr√™n) */}
      <div style={{
        position: 'absolute', top: '20px', right: '20px',
        background: 'rgba(0,0,0,0.7)', padding: '15px', borderRadius: '10px',
        color: 'white', minWidth: '200px',
        border: '1px solid rgba(255,255,255,0.1)'
      }}>
        <h3 style={{ margin: '0 0 10px 0', borderBottom: '1px solid #555', paddingBottom: '8px', color: '#FFD700', textAlign: 'center', fontSize: '16px' }}>üèÜ Top Players</h3>
        <div style={{ display: 'flex', flexDirection: 'column', gap: '5px' }}>
          {leaderboard.length > 0 ? leaderboard.map((player, index) => (
            <div key={player.id} style={{ display: 'flex', justifyContent: 'space-between', fontSize: '14px', color: player.id === socket.myId ? '#4CAF50' : '#fff', fontWeight: player.id === socket.myId ? 'bold' : 'normal', background: player.id === socket.myId ? 'rgba(76, 175, 80, 0.2)' : 'transparent', padding: '2px 5px', borderRadius: '4px' }}>
              <span><span style={{ color: '#888', marginRight: '8px', width: '20px', display: 'inline-block' }}>#{index + 1}</span>{player.name || 'Unknown'}</span>
              <span>{player.score}</span>
            </div>
          )) : <div style={{textAlign: 'center', color: '#aaa', fontSize: '12px'}}>Waiting...</div>}
        </div>
      </div>

      {/* üü¢ 3. MINIMAP (G√≥c ph·∫£i d∆∞·ªõi) */}
      <div style={{
          position: 'absolute', bottom: '20px', right: '20px',
          width: `${MINIMAP_SIZE}px`, height: `${MINIMAP_SIZE}px`,
          background: 'rgba(0, 0, 0, 0.8)',
          border: '2px solid #555', borderRadius: '5px',
          overflow: 'hidden'
      }}>
          {/* Grid lines */}
          <div style={{ position: 'absolute', top: '50%', width: '100%', height: '1px', background: '#333' }}></div>
          <div style={{ position: 'absolute', left: '50%', height: '100%', width: '1px', background: '#333' }}></div>
          
          {/* Ch·∫•m xanh c·ªßa m√¨nh */}
          <div style={{ position: 'absolute', left: myMinimapPos.left, top: myMinimapPos.top, width: '6px', height: '6px', background: '#00FF00', borderRadius: '50%', transform: 'translate(-50%, -50%)', boxShadow: '0 0 4px #00FF00' }} />
          
          {/* Ch·∫•m v√†ng c·ªßa Top 1 */}
          {kingMinimapPos && (
              <div style={{ position: 'absolute', left: kingMinimapPos.left, top: kingMinimapPos.top, width: '8px', height: '8px', background: '#FFD700', borderRadius: '50%', transform: 'translate(-50%, -50%)', border: '1px solid #000', zIndex: 1 }}>
                  <div style={{ position: 'absolute', top: '-10px', left: '-3px', fontSize: '10px' }}>üëë</div>
              </div>
          )}
      </div>

    </div>
  );
};

export default HUD;
</file>

<file path="src/components/LoginScreen.jsx">
import React, { useState } from 'react';
import { socket } from '../network/socket';

const LoginScreen = ({ onJoin }) => {
  const [username, setUsername] = useState('');
  const [connecting, setConnecting] = useState(false);

  const handlePlay = async () => {
    if (!username) return;
    setConnecting(true);
    try {
      await socket.connect(username);
      onJoin(); // B√°o cho App bi·∫øt ƒë√£ k·∫øt n·ªëi xong
    } catch (err) {
      alert('Kh√¥ng th·ªÉ k·∫øt n·ªëi Server!');
      setConnecting(false);
    }
  };

  return (
    <div style={{
      position: 'absolute', top: 0, left: 0, width: '100%', height: '100%',
      display: 'flex', justifyContent: 'center', alignItems: 'center',
      background: 'rgba(0,0,0,0.8)', zIndex: 10
    }}>
      <div style={{
        background: '#fff', padding: '40px', borderRadius: '10px', textAlign: 'center'
      }}>
        <h1 style={{color: '#333'}}>IO GAME REACT</h1>
        <input 
          type="text" 
          placeholder="Nh·∫≠p t√™n..." 
          value={username}
          onChange={(e) => setUsername(e.target.value)}
          onKeyDown={(e) => e.stopPropagation()}
          style={{ padding: '10px', fontSize: '16px', marginBottom: '10px' }}
        />
        <br />
        <button 
          onClick={handlePlay} 
          disabled={connecting}
          style={{ padding: '10px 30px', background: '#4CAF50', color: 'white', border: 'none', cursor: 'pointer' }}
        >
          {connecting ? 'ƒêang k·∫øt n·ªëi...' : 'CH∆†I NGAY'}
        </button>
      </div>
    </div>
  );
};

export default LoginScreen;
</file>

<file path="src/game/config.js">
import Phaser from 'phaser';
import { GameScene } from './scenes/GameScene';

export const gameConfig = {
  type: Phaser.AUTO,
  width: window.innerWidth,
  height: window.innerHeight,
  parent: 'game-container', // ID c·ªßa th·∫ª DIV trong React
  backgroundColor: '#1a1a1a',
  physics: {
    default: 'arcade',
    arcade: {
      debug: false, // B·∫≠t true ƒë·ªÉ xem hitbox
    },
  },
  scene: [GameScene], // Danh s√°ch c√°c m√†n ch∆°i
  scale: {
    mode: Phaser.Scale.RESIZE,
    autoCenter: Phaser.Scale.CENTER_BOTH
  }
};
</file>

<file path="src/game/entities/ClientPlayer.js">
import Phaser from 'phaser';
import { socket } from '../../network/socket';

export class ClientPlayer {
    constructor(scene, playerData) {
        this.scene = scene;
        this.id = playerData.id;
        this.name = playerData.name;
        this.score = playerData.score || 0;

        // L∆∞u v·ªã tr√≠ hi·ªán t·∫°i
        this.x = playerData.x;
        this.y = playerData.y;

        // Bi·∫øn l∆∞u v·ªã tr√≠ ƒë√≠ch (Target) ƒë·ªÉ Lerp
        this.targetX = playerData.x;
        this.targetY = playerData.y;

        this.weaponType = playerData.weapon || 'PISTOL';
        this.isMoving = playerData.isMoving || false;

        // --- 1. T·∫°o Container ---
        this.container = scene.add.container(playerData.x, playerData.y);

        // X√°c ƒë·ªãnh m√†u: M√¨nh (Xanh), ƒê·ªãch (ƒê·ªè)
        this.isMe = (this.id === socket.myId);
        const color = this.isMe ? 0x4CAF50 : 0xE53935;

        // V·∫Ω th√¢n (Circle)
        const circle = scene.add.circle(0, 0, 20, color);

        // V·∫Ω s√∫ng (Rectangle)
        const weapon = scene.add.rectangle(15, 0, 20, 8, 0xFFFFFF);

        this.container.add([weapon, circle]);
        this.container.setDepth(1); // L·ªõp d∆∞·ªõi

        // --- 2. T·∫°o T√™n & Thanh M√°u ---

        // T√™n (Gi·ªØ nguy√™n code c·ªßa b·∫°n)
        this.text = scene.add.text(playerData.x, playerData.y - 40, this.name, {
            fontSize: '14px',
            fontFamily: 'Arial',
            color: '#FFFFFF',
            stroke: '#000000',
            strokeThickness: 3,
            align: 'center'
        }).setOrigin(0.5);
        this.text.setDepth(2);

        // B·ªî SUNG: Thanh m√°u (Th√™m m·ªõi)
        // N·ªÅn ƒëen
        this.healthBarBg = scene.add.rectangle(playerData.x, playerData.y - 25, 40, 6, 0x000000);
        this.healthBarBg.setDepth(2);

        //Shield bar
        this.shieldCircle = scene.add.circle(0, 0, 25, 0x00FFFF, 0);
        this.shieldCircle.setStrokeStyle(3, 0x00FFFF, 0.6);
        this.container.add(this.shieldCircle); // Add v√†o container ƒë·ªÉ t·ª± ƒë·ªông follow
        this.shieldCircle.setVisible(false); // ·∫®n m·∫∑c ƒë·ªãnh

        // Thanh m√°u xanh (M√°u th·ª±c t·∫ø)
        this.healthBar = scene.add.rectangle(playerData.x, playerData.y - 25, 40, 4, 0x00FF00);
        this.healthBar.setDepth(2);
    }

    //  H√†m 1: Nh·∫≠n d·ªØ li·ªáu t·ª´ Server (Ch·ªâ l∆∞u ƒë√≠ch ƒë·∫øn & State)
    updateServerData(data) {
        // 1. X·ª≠ l√Ω Ch·∫øt/S·ªëng
        if (data.dead) {
            this.container.setVisible(false);
            this.text.setVisible(false);
            this.healthBar.setVisible(false);   // ·∫®n m√°u
            this.healthBarBg.setVisible(false); // ·∫®n n·ªÅn m√°u
            return;
        }

        // N·∫øu ƒëang s·ªëng th√¨ hi·ªán l√™n
        this.container.setVisible(true);
        this.text.setVisible(true);
        this.healthBar.setVisible(true);
        this.healthBarBg.setVisible(true);

        // 2. C·∫≠p nh·∫≠t ƒê√≠ch ƒë·∫øn (Target)
        this.targetX = data.x;
        this.targetY = data.y;

        // C·∫≠p nh·∫≠t g√≥c quay
        this.container.rotation = data.angle;

        // 3. C·∫≠p nh·∫≠t d·ªØ li·ªáu game (Score)
        this.score = data.score;

        //  C·∫≠p nh·∫≠t weapon type & movement state
        this.weaponType = data.weapon || 'PISTOL';
        this.isMoving = data.isMoving || false;

        // B·ªî SUNG: C·∫≠p nh·∫≠t Thanh M√°u
        if (data.maxHealth) {
            // T√≠nh ph·∫ßn trƒÉm m√°u (Max l√† 40px chi·ªÅu r·ªông)
            const percent = Math.max(0, data.health / data.maxHealth);
            this.healthBar.width = 40 * percent;

            // ƒê·ªïi m√†u: M√°u th·∫•p (<30%) th√¨ ƒë·ªè, c√≤n l·∫°i xanh
            if (percent < 0.3) {
                this.healthBar.fillColor = 0xFF0000;
            } else {
                this.healthBar.fillColor = 0x00FF00;
            }
        }

        // 4. X·ª≠ l√Ω L·ªõn l√™n (Scale)
        if (data.radius) {
            const defaultRadius = 20;
            const scale = data.radius / defaultRadius;
            this.container.setScale(scale);
        }

        // B·ªî SUNG: Hi·ªáu ·ª©ng Shield
        // C·∫≠p nh·∫≠t shield visual
        if (data.hasShield) {
            this.shieldCircle.setVisible(true);
            this.shieldCircle.radius = (data.radius || 20) + 8; // L·ªõn h∆°n player 1 ch√∫t
        } else {
            this.shieldCircle.setVisible(false);
        }
    }

    // H√ÄM 2: Ch·∫°y m·ªói frame ƒë·ªÉ di chuy·ªÉn m∆∞·ª£t (Lerp)
    tick(dt) {
        // N·∫øu nh√¢n v·∫≠t ƒëang ·∫©n (ch·∫øt) th√¨ kh√¥ng c·∫ßn t√≠nh to√°n di chuy·ªÉn
        if (!this.container.visible) return;

        const t = 0.2; // H·ªá s·ªë l√†m m∆∞·ª£t

        // N·ªôi suy v·ªã tr√≠ Container
        this.container.x = Phaser.Math.Linear(this.container.x, this.targetX, t);
        this.container.y = Phaser.Math.Linear(this.container.y, this.targetY, t);

        // C·∫≠p nh·∫≠t t·ªça ƒë·ªô public
        this.x = this.container.x;
        this.y = this.container.y;

        // --- ƒê·ªíNG B·ªò UI THEO NG∆Ø·ªúI ---
        const currentScale = this.container.scaleX;

        // 1. T√™n
        this.text.x = this.container.x;
        this.text.y = this.container.y - (40 * currentScale);

        // 2. B·ªî SUNG: Thanh m√°u ch·∫°y theo ng∆∞·ªùi
        this.healthBarBg.x = this.container.x;
        this.healthBarBg.y = this.container.y - (25 * currentScale);

        this.healthBar.x = this.container.x;
        this.healthBar.y = this.container.y - (25 * currentScale);
    }

    destroy() {
        this.container.destroy();
        this.text.destroy();
        // B·ªî SUNG: X√≥a thanh m√°u khi player tho√°t/ch·∫øt h·∫≥n
        this.healthBar.destroy();
        this.healthBarBg.destroy();
        this.shieldCircle.destroy();
    }
}
</file>

<file path="src/game/scenes/GameScene.js">
import Phaser from 'phaser';
import { socket } from '../../network/socket';
import { PacketType } from '@shared/packetTypes';
import { ClientPlayer } from '../entities/ClientPlayer';
import { WEAPON_STATS } from '@shared/constants';

export class GameScene extends Phaser.Scene {
    constructor() {
        super('GameScene');
        this.players = {};
        this.foods = {};
        this.keys = null;
        this.projectileGroup = null;
        this.foodGroup = null;
        this.obstacleGroup = null;
        this.chestGroup = null;
        this.chests = {};
        this.itemGroup = null;
        this.items = {};

        // Th√™m range circle cho player
        this.rangeCircle = null;

        // Group cho explosions
        this.explosionGroup = null;
    }

    create() {
        // 1. Background
        this.add.grid(0, 0, 5000, 5000, 100, 100, 0x1a1a1a, 1, 0x2a2a2a, 1);

        // 2. Input Keyboard
        this.keys = this.input.keyboard.addKeys({
            W: Phaser.Input.Keyboard.KeyCodes.W,
            A: Phaser.Input.Keyboard.KeyCodes.A,
            S: Phaser.Input.Keyboard.KeyCodes.S,
            D: Phaser.Input.Keyboard.KeyCodes.D,
            UP: Phaser.Input.Keyboard.KeyCodes.UP,
            DOWN: Phaser.Input.Keyboard.KeyCodes.DOWN,
            LEFT: Phaser.Input.Keyboard.KeyCodes.LEFT,
            RIGHT: Phaser.Input.Keyboard.KeyCodes.RIGHT,
            SPACE: Phaser.Input.Keyboard.KeyCodes.SPACE
        });

        // 3. Groups (KH·ªûI T·∫†O TR∆Ø·ªöC KHI SOCKET CH·∫†Y)
        this.projectileGroup = this.add.group();
        this.foodGroup = this.add.group();
        this.obstacleGroup = this.add.group();
        this.chestGroup = this.add.group();
        this.itemGroup = this.add.group();
        this.explosionGroup = this.add.group();

        // 4. T·∫°o Range Circle (·ªû layer d∆∞·ªõi c√πng)
        this.rangeCircle = this.add.circle(0, 0, 100, 0xFFFFFF, 0);
        this.rangeCircle.setStrokeStyle(2, 0xFFFFFF, 0.3);
        this.rangeCircle.setDepth(10); // D∆∞·ªõi m·ªçi th·ª©

        // 5. Input Mouse
        this.input.on('pointerdown', (pointer) => {
            socket.send({ type: PacketType.ATTACK });
        });

        console.log('GameScene Created - Waiting for socket...');

        // 6. SETUP SOCKET ·ªû CU·ªêI C√ôNG (Fix l·ªói Initialization Order)
        socket.setGameScene(this);
    }

    update(time, delta) {
        if (!socket.isConnected) return;

        // Logic Lerp Player
        const dt = delta / 1000;
        Object.values(this.players).forEach(player => {
            if (player.tick) {
                player.tick(dt);
            }
        });

        // C·∫≠p nh·∫≠t Range Circle theo player hi·ªán t·∫°i
        const myPlayer = this.players[socket.myId];
        if (myPlayer && myPlayer.container.visible) {
            const weaponType = myPlayer.weaponType || 'PISTOL';
            const stats = WEAPON_STATS[weaponType];

            // C·∫≠p nh·∫≠t v·ªã tr√≠ v√† k√≠ch th∆∞·ªõc
            this.rangeCircle.x = myPlayer.x;
            this.rangeCircle.y = myPlayer.y;
            this.rangeCircle.radius = stats.range;
            this.rangeCircle.setVisible(true);

            // ƒê·ªïi m√†u n·∫øu l√† Sniper v√† ƒëang di chuy·ªÉn (kh√¥ng b·∫Øn ƒë∆∞·ª£c)
            if (stats.requireStill && myPlayer.isMoving) {
                this.rangeCircle.setStrokeStyle(2, 0xFF0000, 0.5); // ƒê·ªè = kh√¥ng b·∫Øn ƒë∆∞·ª£c
            } else {
                this.rangeCircle.setStrokeStyle(2, 0xFFFFFF, 0.3); // Tr·∫Øng = b√¨nh th∆∞·ªùng
            }
        } else {
            this.rangeCircle.setVisible(false);
        }

        // Input Logic
        const pointer = this.input.activePointer;
        const worldPoint = this.cameras.main.getWorldPoint(pointer.x, pointer.y);

        const inputData = {
            movement: {
                up: this.keys.W.isDown || this.keys.UP.isDown,
                down: this.keys.S.isDown || this.keys.DOWN.isDown,
                left: this.keys.A.isDown || this.keys.LEFT.isDown,
                right: this.keys.D.isDown || this.keys.RIGHT.isDown,
                space: this.keys.SPACE.isDown,
            },
            mouseX: worldPoint.x,
            mouseY: worldPoint.y
        };

        socket.send({ type: PacketType.INPUT, data: inputData });
    }

    // --- SOCKET HANDLERS ---

    initGame(data) {
        if (data.players) data.players.forEach(p => this.addPlayer(p));

        if (data.foods) {
            this.foodGroup.clear(true, true);
            this.foods = {};
            data.foods.forEach(f => this.createFoodSprite(f));
        }

        if (data.obstacles) {
            data.obstacles.forEach(obs => {
                const rock = this.add.circle(obs.x, obs.y, obs.radius, 0x888888);
                rock.setStrokeStyle(3, 0x555555);
                this.obstacleGroup.add(rock);
            });
        }

        if (data.chests) {
            this.chestGroup.clear(true, true);
            this.chests = {};
            data.chests.forEach(c => this.createChestSprite(c));
        }

        if (data.items) {
            this.itemGroup.clear(true, true);
            this.items = {};
            data.items.forEach(i => this.createItemSprite(i));
        }

        if (this.players[data.id]) {
            this.cameras.main.startFollow(this.players[data.id].container);
            this.cameras.main.setZoom(1);
        }
    }

    handleServerUpdate(packet) {
        // L·ªöP B·∫¢O V·ªÜ TUY·ªÜT ƒê·ªêI (Fix l·ªói crash: reading 'size' of undefined)
        if (!this.chestGroup || !this.itemGroup || !this.projectileGroup || !this.foodGroup) {
            return;
        }

        // 1. Update Players
        if (packet.players) {
            packet.players.forEach(p => {
                const player = this.players[p.id];
                if (player) {
                    if (player.updateServerData) player.updateServerData(p);
                    else player.update(p);
                } else {
                    this.addPlayer(p);
                }
            });
        }

        // 2. Update Foods
        if (packet.foodsRemoved) {
            packet.foodsRemoved.forEach(id => {
                if (this.foods[id]) {
                    this.foods[id].destroy();
                    delete this.foods[id];
                }
            });
        }
        if (packet.foodsAdded) packet.foodsAdded.forEach(f => this.createFoodSprite(f));
        if (packet.foods) { // Full sync fallback
            this.foodGroup.clear(true, true);
            this.foods = {};
            packet.foods.forEach(f => this.createFoodSprite(f));
        }

        // 3. Update Projectiles
        if (packet.projectiles) {
            this.projectileGroup.clear(true, true);
            packet.projectiles.forEach(p => {
                const radius = p.radius || 6;
                // V·∫Ω ƒë·∫°n d·ª±a tr√™n m√†u server g·ª≠i v·ªÅ (n·∫øu c√≥), m·∫∑c ƒë·ªãnh v√†ng
                let color = 0xFFFF00; // M·∫∑c ƒë·ªãnh v√†ng
                if (p.weaponType && WEAPON_STATS[p.weaponType]) {
                    color = WEAPON_STATS[p.weaponType].color;
                }
                const bullet = this.add.circle(p.x, p.y, radius, color);
                this.projectileGroup.add(bullet);
            });
        }

        //  4. Update Explosions (Hi·ªáu ·ª©ng n·ªï)
        if (packet.explosions) {
            this.explosionGroup.clear(true, true);
            packet.explosions.forEach(e => {
                // V·∫Ω v√≤ng tr√≤n n·ªï v·ªõi hi·ªáu ·ª©ng
                const circle = this.add.circle(e.x, e.y, e.radius, 0xFF4400, 0.4);
                circle.setStrokeStyle(3, 0xFF0000, 0.8);

                // Animation ph√≥ng to + m·ªù d·∫ßn
                this.tweens.add({
                    targets: circle,
                    scaleX: 1.5,
                    scaleY: 1.5,
                    alpha: 0,
                    duration: 200,
                    ease: 'Power2',
                    onComplete: () => circle.destroy()
                });

                this.explosionGroup.add(circle);
            });
        }

        // 5. Update Chests
        if (packet.chestsRemoved) {
            packet.chestsRemoved.forEach(id => {
                if (this.chests[id]) {
                    this.chests[id].destroy();
                    delete this.chests[id];
                }
            });
        }
        if (packet.chestsAdded) packet.chestsAdded.forEach(c => this.createChestSprite(c));

        // 6. Update Items
        if (packet.itemsRemoved) {
            packet.itemsRemoved.forEach(id => {
                if (this.items[id]) {
                    this.items[id].destroy();
                    delete this.items[id];
                }
            });
        }
        if (packet.itemsAdded) packet.itemsAdded.forEach(i => this.createItemSprite(i));
    }

    addPlayer(playerData) {
        if (this.players[playerData.id]) return;
        this.players[playerData.id] = new ClientPlayer(this, playerData);
    }

    removePlayer(id) {
        if (this.players[id]) {
            this.players[id].destroy();
            delete this.players[id];
        }
    }

    createFoodSprite(f) {
        if (this.foods[f.id]) return;
        let color = 0xFFFFFF;
        if (f.type === 0) color = 0xFF4444;
        if (f.type === 1) color = 0x44FF44;
        if (f.type === 2) color = 0x4444FF;
        const food = this.add.circle(f.x, f.y, 5, color);
        this.foodGroup.add(food);
        this.foods[f.id] = food;
    }

    createChestSprite(c) {
        if (this.chests[c.id]) return;
        const chest = this.add.rectangle(c.x, c.y, 40, 40, 0xCD853F);
        chest.setStrokeStyle(2, 0xFFFFFF);
        this.chestGroup.add(chest);
        this.chests[c.id] = chest;
    }

    createItemSprite(i) {
        if (this.items[i.id]) return;

        let color = 0xFFFFFF;
        let text = "?";
        let fontSize = '11px';

        switch (i.type) {
            case 'HEALTH_PACK': color = 0xFF0000; text = "HP"; break;
            case 'SHIELD': color = 0x00FFFF; text = "SHD"; break;
            case 'SPEED': color = 0xFFFF00; text = "SPD"; break;
            case 'WEAPON_ROCKET': color = 0xFF4500; text = "RKT"; break;
            case 'WEAPON_SHOTGUN': color = 0xFFA500; text = "SHT"; break;
            case 'WEAPON_MACHINEGUN': color = 0xADFF2F; text = "MG"; break;
            case 'WEAPON_SNIPER': color = 0x00BFFF; text = "SNP"; break; 
            case 'WEAPON_PISTOL': color = 0xFFFF00; text = "PST"; break; // 
            default: if (i.type.includes('WEAPON')) { color = 0x9933FF; text = "W"; }
        }

        const container = this.add.container(i.x, i.y);
        const circle = this.add.circle(0, 0, 15, color);
        circle.setStrokeStyle(2, 0x000000);
        const label = this.add.text(0, 0, text, { fontSize, color: '#000000', fontFamily: 'Arial', fontWeight: 'bold' }).setOrigin(0.5);

        container.add([circle, label]);
        this.tweens.add({
            targets: container, scaleX: 1.15, scaleY: 1.15,
            yoyo: true, repeat: -1, duration: 600, ease: 'Sine.easeInOut'
        });

        this.itemGroup.add(container);
        this.items[i.id] = container;
    }

    updateFoods(foodsData) {
        this.foodGroup.clear(true, true);
        this.foods = {};
        foodsData.forEach(f => this.createFoodSprite(f));
    }

    getLeaderboard() {
        return Object.values(this.players).map(p => ({ name: p.name, score: p.score })).sort((a, b) => b.score - a.score).slice(0, 10);
    }
}
</file>

<file path="src/index.css">
body {
  margin: 0;
  padding: 0;
  overflow: hidden; /* ·∫®n thanh cu·ªôn */
  background-color: #000;
}
</file>

<file path="src/main.jsx">
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.jsx'

createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
</file>

<file path="src/network/socket.js">
import { PacketType } from '@shared/packetTypes';

class NetworkManager {
  constructor() {
    this.ws = null;
    this.gameScene = null;
    
    // Bi·∫øn n√†y ƒë·ªÉ HUD bi·∫øt ai l√† ng∆∞·ªùi ch∆°i hi·ªán t·∫°i
    this.myId = null; 
    
    this.isConnected = false;
    this.listeners = [];
  }

  connect(username) {
    return new Promise((resolve, reject) => {
      this.ws = new WebSocket('ws://localhost:3000');

      this.ws.onopen = () => {
        this.isConnected = true;
        console.log('Connected via WebSocket');
        this.send({ type: PacketType.JOIN, name: username });
        resolve();
      };

      this.ws.onerror = (err) => {
        console.error('WebSocket error', err);
        reject(err);
      };

      this.ws.onmessage = (event) => this.handleMessage(event);
      
      this.ws.onclose = () => {
        this.isConnected = false;
        console.log('üîå Disconnected');
      };
    });
  }

  setGameScene(scene) {
    this.gameScene = scene;
  }

  send(data) {
    if (this.isConnected && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(data));
    }
  }

  subscribe(callback) {
    this.listeners.push(callback);
    return () => {
      this.listeners = this.listeners.filter(l => l !== callback);
    };
  }

  handleMessage(event) {
    const packet = JSON.parse(event.data);

    // 1. X·ª≠ l√Ω Logic Game (Phaser)
    if (this.gameScene) {
      switch (packet.type) {
        case PacketType.UPDATE:
          this.gameScene.handleServerUpdate(packet);
          // G·ª≠i data sang React HUD
          this.notifyReact(packet);
          break;

        case PacketType.INIT:
          // QUAN TR·ªåNG: L∆∞u ID c·ªßa m√¨nh khi server c·∫•p
          this.myId = packet.id;
          
          this.gameScene.initGame(packet);
          this.notifyReact(packet);
          break;

        case PacketType.PLAYER_JOIN:
          this.gameScene.addPlayer(packet.player);
          break;

        case PacketType.PLAYER_LEAVE:
          this.gameScene.removePlayer(packet.id);
          break;
      }
    }

    // 2. X·ª≠ l√Ω packet t·ª´ React (DeathScreen, HUD)
    if (packet.type === PacketType.PLAYER_DIED) {
      this.notifyReact(packet);
    }

    if (packet.type === PacketType.PING) {
      this.send({ type: PacketType.PONG });
    }
  }

  notifyReact(data) {
    this.listeners.forEach(callback => callback(data));
  }
}

export const socket = new NetworkManager();
</file>

<file path="vite.config.js">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    fs: {
      // Cho ph√©p Vite truy c·∫≠p v√†o th∆∞ m·ª•c c·∫•p cao h∆°n (ƒë·ªÉ ƒë·ªçc folder shared)
      allow: ['..'] 
    }
  },
  resolve: {
    alias: {
      // T·∫°o ƒë∆∞·ªùng d·∫´n t·∫Øt '@shared' ƒë·ªÉ import cho g·ªçn
      '@shared': path.resolve(__dirname, '../shared/src') 
    }
  }
})
</file>

</files>
